# 1 ".././menu.c"
# 1 "E:\\Users\\Anwender\\Sync\\Atmel Studio\\Pipe1\\Pipe1\\Debug//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 ".././menu.c"







# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 1 3
# 99 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 1 3
# 126 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 1 3
# 37 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 1 3 4
# 9 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 3 4
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 1 3 4
# 125 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4

# 125 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef signed int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef signed int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 146 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 163 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 217 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 277 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 10 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 2 3 4
# 38 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 2 3
# 77 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 2 3
# 100 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 174 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iom2560.h" 1 3
# 38 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iom2560.h" 3
# 1 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iomxx0_1.h" 1 3
# 1630 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iomxx0_1.h" 3
       
# 1631 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iomxx0_1.h" 3

       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
# 39 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\atmel\\ATmega_DFP\\1.2.209\\include/avr/iom2560.h" 2 3
# 175 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 627 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\portpins.h" 1 3
# 628 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\common.h" 1 3
# 630 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\version.h" 1 3
# 632 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3






# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\fuse.h" 1 3
# 239 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\fuse.h" 3
typedef struct
{
    unsigned char low;
    unsigned char high;
    unsigned char extended;
} __fuse_t;
# 639 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\lock.h" 1 3
# 642 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 9 ".././menu.c" 2

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 1 3 4
# 149 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 216 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 328 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef int wchar_t;
# 11 ".././menu.c" 2

# 1 ".././lcd_u.h" 1
# 82 ".././lcd_u.h"

# 82 ".././lcd_u.h"
extern uint8_t lcd_cursorPos;


extern void lcd_write_nibble(uint8_t data);
extern void lcd_write_command(uint8_t data);
extern void lcd_write_character(uint8_t data);

extern void lcd_init();
extern void lcd_clrscr();
extern void lcd_home();
extern void lcd_goto(uint8_t pos);
extern void lcd_putc(char c);
extern void lcd_puts(const char *s);
extern void lcd_puts_P(const char *progmem_s);
# 13 ".././menu.c" 2
# 1 ".././message.h" 1
# 11 ".././message.h"
# 1 ".././utils.h" 1
# 9 ".././utils.h"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 1 3
# 89 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 1 3 4
# 90 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 2 3
# 1158 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3

# 1158 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern const void * memchr_P(const void *, int __val, size_t __len) __attribute__((__const__));
# 1172 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int memcmp_P(const void *, const void *, size_t) __attribute__((__pure__));






extern void *memccpy_P(void *, const void *, int __val, size_t);
# 1188 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern void *memcpy_P(void *, const void *, size_t);






extern void *memmem_P(const void *, size_t, const void *, size_t) __attribute__((__pure__));
# 1207 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern const void * memrchr_P(const void *, int __val, size_t __len) __attribute__((__const__));
# 1217 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strcat_P(char *, const char *);
# 1233 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern const char * strchr_P(const char *, int __val) __attribute__((__const__));
# 1245 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern const char * strchrnul_P(const char *, int __val) __attribute__((__const__));
# 1258 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strcmp_P(const char *, const char *) __attribute__((__pure__));
# 1268 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strcpy_P(char *, const char *);
# 1285 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strcasecmp_P(const char *, const char *) __attribute__((__pure__));






extern char *strcasestr_P(const char *, const char *) __attribute__((__pure__));
# 1305 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strcspn_P(const char *__s, const char * __reject) __attribute__((__pure__));
# 1321 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strlcat_P (char *, const char *, size_t );
# 1334 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strlcpy_P (char *, const char *, size_t );
# 1346 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strnlen_P(const char *, size_t) __attribute__((__const__));
# 1357 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strncmp_P(const char *, const char *, size_t) __attribute__((__pure__));
# 1376 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strncasecmp_P(const char *, const char *, size_t) __attribute__((__pure__));
# 1387 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strncat_P(char *, const char *, size_t);
# 1401 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strncpy_P(char *, const char *, size_t);
# 1416 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strpbrk_P(const char *__s, const char * __accept) __attribute__((__pure__));
# 1427 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern const char * strrchr_P(const char *, int __val) __attribute__((__const__));
# 1447 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strsep_P(char **__sp, const char * __delim);
# 1460 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strspn_P(const char *__s, const char * __accept) __attribute__((__pure__));
# 1474 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strstr_P(const char *, const char *) __attribute__((__pure__));
# 1496 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strtok_P(char *__s, const char * __delim);
# 1516 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strtok_rP(char *__s, const char * __delim, char **__last);
# 1529 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strlen_PF(uint_farptr_t src) __attribute__((__const__));
# 1545 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strnlen_PF(uint_farptr_t src, size_t len) __attribute__((__const__));
# 1560 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern void *memcpy_PF(void *dest, uint_farptr_t src, size_t len);
# 1575 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strcpy_PF(char *dest, uint_farptr_t src);
# 1595 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strncpy_PF(char *dest, uint_farptr_t src, size_t len);
# 1611 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strcat_PF(char *dest, uint_farptr_t src);
# 1632 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strlcat_PF(char *dst, uint_farptr_t src, size_t siz);
# 1649 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strncat_PF(char *dest, uint_farptr_t src, size_t len);
# 1665 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strcmp_PF(const char *s1, uint_farptr_t s2) __attribute__((__pure__));
# 1682 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strncmp_PF(const char *s1, uint_farptr_t s2, size_t n) __attribute__((__pure__));
# 1698 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strcasecmp_PF(const char *s1, uint_farptr_t s2) __attribute__((__pure__));
# 1716 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int strncasecmp_PF(const char *s1, uint_farptr_t s2, size_t n) __attribute__((__pure__));
# 1732 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern char *strstr_PF(const char *s1, uint_farptr_t s2);
# 1744 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t strlcpy_PF(char *dst, uint_farptr_t src, size_t siz);
# 1760 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern int memcmp_PF(const void *, uint_farptr_t, size_t) __attribute__((__pure__));
# 1779 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\pgmspace.h" 3
extern size_t __strlen_P(const char *) __attribute__((__const__));
__attribute__((__always_inline__)) static __inline__ size_t strlen_P(const char * s);
static __inline__ size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
}
# 10 ".././utils.h" 2







# 16 ".././utils.h"
typedef union{
 uint32_t longval;
 uint8_t byteval[4];
 } Longint_t;

extern Longint_t editLong;
extern uint8_t editByte;

typedef union{
 uint16_t wordval;
 uint8_t byteval[2];
 } Word_t;

extern uint8_t lcd_cursorIsOn;

extern uint8_t nibbleToChr(uint8_t myNibble);
# 41 ".././utils.h"
extern void lcd_initCG();
extern void lcd_setCG(uint8_t charNr, const uint8_t* patternPtr);
extern void lcd_wordout(uint16_t hexNumber);
extern void lcd_hexout(uint8_t hexNumber);
extern void lcd_ManualOut(uint8_t manual);
extern void lcd_ManualOutDec(uint8_t manual);
extern void lcd_ChannelOut(uint8_t channel);
extern void lcd_longout();
extern void lcd_cursoroff();
extern void lcd_cursosblink();
extern void lcd_blank(uint8_t count);
extern void lcd_dec2out(uint8_t val);
extern void lcd_clrEol();
extern void lcd_waitSymbolOn();
extern void lcd_waitSymbolOff();
extern uint8_t lcd_noteOut(uint8_t noteNr);

extern char* putChar_Dec2(uint8_t val, char* pOutput);
extern char* putChar_hex(uint8_t val, char* pOutput);
extern char* putChar_long(uint16_t val, char* pOutput);
extern char* putChar_Note(uint8_t note, char* pOutput);
extern char* putChar_Manual(uint8_t manual, char* pOutput);

extern uint8_t lcd_edit_longint(uint8_t cursor);
extern uint8_t lcd_edit_byte(uint8_t cursor);
# 75 ".././utils.h"
extern const __flash char keylabel_plus [] ;
extern const __flash char keylabel_minus [] ;
extern const __flash char keylabel_up [] ;
extern const __flash char keylabel_down [] ;
extern const __flash char keylabel_right [] ;
extern const __flash char keylabel_left [] ;
extern const __flash char keylabel_onoff [] ;
extern const __flash char keylabel_exit [] ;
extern const __flash char keylabel_text [] ;
extern const __flash char keylabel_0 [] ;
extern const __flash char keylabel_1 [] ;

extern void keylabel_set(uint8_t keyNr, const __flash char* labelPStr);
extern void keylabel_toLCD();
extern void keylabel_clr(uint8_t keyNr);
extern uint8_t keylabel_statcheck(uint8_t keyNr, uint8_t status);
# 100 ".././utils.h"
extern char string_Buf[40];

extern const char cr_lf [] 
# 102 ".././utils.h" 3
                          __attribute__((__progmem__))
# 102 ".././utils.h"
                                 ;
# 12 ".././message.h" 2



extern void init_message (void);
extern void message_push (uint8_t msg);
extern uint8_t message_get (void);
extern uint8_t message_status (void);
extern uint8_t message_peek();
extern volatile uint8_t msgOverflow;
# 64 ".././message.h"
typedef union {
 uint16_t Message16;
 uint8_t message8[2];
} PipeMessage_t;

extern void pipeMsgInit (void);
extern void pipeMsgPush (PipeMessage_t message);
extern PipeMessage_t pipeMsgGet (void);
extern uint8_t pipeMsgStatus (void);
extern volatile uint8_t msgPipeOverflow;
extern uint8_t msgPipe_Handling;
# 14 ".././menu.c" 2
# 1 ".././hwtimer.h" 1
# 14 ".././hwtimer.h"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 1 3
# 38 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\interrupt.h" 1 3
# 39 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 2 3




# 42 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 3
static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)((0x3F) + 0x20)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 15 ".././hwtimer.h" 2
# 31 ".././hwtimer.h"

# 31 ".././hwtimer.h"
extern volatile uint8_t time_Uptime[4];
# 77 ".././hwtimer.h"
typedef struct {
 uint8_t counter;
 uint8_t prescaler;
} Timer;
extern volatile Timer swTimer[9];
extern volatile uint8_t time_Uptime[4];
extern volatile uint8_t time_UpTimeUpdated;

extern void init_HwTimer();
extern void init_Timers();
extern void init_ADC();
extern void init_Pipe();
# 130 ".././hwtimer.h"
typedef struct {
 uint8_t mux;
 uint8_t ADCval;
 uint8_t key;

 uint8_t keyRepeating;
 uint16_t keyTimer;
} KeyInfo;
extern volatile KeyInfo adcKeys[1];

extern uint8_t keyWants[6];
# 163 ".././hwtimer.h"
typedef struct {
 uint8_t pipeOutM4;
 uint8_t pipeOut;
 uint8_t pipeInM16;
 uint8_t pipeInM12;
 uint8_t pipeInM8;
 uint8_t pipeInM4;
 uint8_t pipeIn;
 uint8_t pipeInStat;
} Pipe_t;
extern Pipe_t pipe[32];






extern volatile uint8_t pipeProcessing;

extern uint8_t pipe_ModuleTested;
extern uint8_t pipe_ModuleAssnRead;
extern uint8_t pipe_ModuleAssnWrite;
# 193 ".././hwtimer.h"
extern uint8_t pipe_PowerStatus;



extern uint8_t module_TestAllInputs();
extern void module_WaitOutputInput2Cycles();
extern void module_StartPowerOn();
extern void module_PowerControl();
extern void softKey_WantLong(uint8_t wantLong);
extern void Pipes_AllOutputsOff();
extern void init_PipeModules();
extern uint32_t test_PipeModule(uint8_t moduleNr);
# 15 ".././menu.c" 2
# 1 ".././utils.h" 1
# 16 ".././menu.c" 2
# 1 ".././serial.h" 1
# 34 ".././serial.h"
extern void init_Serial0SerUSB();
extern void serial0SER_USBSend(uint8_t data);
extern void serial0SER_USB_sendStringP(const char *progmem_s);
extern void serial0SER_USB_sendString(char *s);
extern void serial0SER_USB_sendCRLF();
extern uint8_t serial0SER_USBReadRx();

extern volatile uint8_t serusbRxInIndex;
extern volatile uint8_t serusbRxOutIndex;
extern volatile uint8_t serusbTxOutIndex;
extern volatile uint8_t serusbTxInIndex;
extern volatile uint8_t serusbOvflFlag;
extern volatile uint8_t serusb_Active;

extern uint8_t serUsbRxBuffer[64];
extern uint8_t serUsbTxBuffer[256];
extern volatile uint16_t midiTxBytesCount;
extern volatile uint16_t midiRxBytesCount;
# 77 ".././serial.h"
extern void init_Serial1MIDI();
extern void serial1MIDISend(uint8_t data);
extern uint8_t serial1MIDIReadRx();

extern volatile uint8_t midiRxInIndex;
extern volatile uint8_t midiRxOutIndex;
extern volatile uint8_t midiTxOutIndex;
extern volatile uint8_t midiTxInIndex;
extern uint8_t midiRxBuffer[32];
extern uint8_t midiTxBuffer[32];
extern volatile uint16_t midiTxBytesCount;
extern volatile uint16_t midiRxBytesCount;
extern volatile uint8_t midiRxOvflCount;
extern volatile uint8_t midiTxOvflCount;
# 17 ".././menu.c" 2
# 1 ".././menu.h" 1







# 1 ".././hw_defs.h" 1
# 9 ".././menu.h" 2
# 51 ".././menu.h"
typedef uint8_t (*MenuFunc_t) (uint8_t arg);

typedef struct Menu {
 const uint8_t menuType;
 const uint8_t menuFlags;
 const char text [10];
 const __flash struct Menu *pMenu;
 union {
  uint8_t * pVar;
  uint16_t tag;
  const __flash char* pString;
 };
 MenuFunc_t pFunc;

 MenuFunc_t pOnExitFunc;


} Menu_t;
# 165 ".././menu.h"
extern const __flash Menu_t * menuStack[16];

uint8_t lcdData[10];




typedef struct {
 uint8_t nibbleCount;
 uint8_t nibblePos[8];
} NibbleInfo_t;

extern uint16_t DataAdressOffset;
extern uint8_t menuNote;
extern uint8_t menuMidiChan;
extern uint8_t menuSection;
extern uint8_t menuManual;
extern uint8_t menuTestModuleBit;
extern uint8_t menuTestData;
extern uint8_t menuVmidiChan;
extern uint8_t menuVsection;
extern uint8_t menuVmanual;
extern uint8_t menuVkey;
extern uint8_t menuVmodule;
extern uint8_t menuVKombination;
extern uint32_t menuModVal;
extern const __flash char* pMenuTopTitle;
extern const __flash Menu_t* menuVMenuSoftKey;
extern uint8_t menuVSoftKey;

extern void menuCurrMenuToLCD();
extern void menuParentMenuToLCD();
extern void menuTextOut(const __flash char* pChar, char finalChar);
extern void menuItemChanged();
extern void menuCursorSetExtra();
extern void menuCursorSetMenu();
extern void menuResetVars();
extern void menuClearMenuDisp();
extern void menu_ClearDataDisp();
extern void menuClearExtraDisp();
extern void menuDisplayValue();
extern void menuTextOut(const __flash char* pChar, char finalChar);
extern void menuCursorSetDataNibble();

extern void nibbleToData();
extern void nibbleChange(uint8_t nibbleNr , int8_t addValue);
extern uint8_t nibbleCheckOvfl(int8_t myNibble);
extern void LCDStringOut();
extern void nibbleToLCDstring();
extern void dataToNibbles();
# 223 ".././menu.h"
typedef struct{
 const __flash struct Menu *pSelMenu;
} SoftKeyMenu_List_t;


extern uint8_t soft_KeyMenuIndex[4];
extern SoftKeyMenu_List_t soft_KeyMenu[4];

extern void init_SoftKeys();
extern void softKey_Set(const __flash Menu_t* pSoftKey, uint8_t nrSoftKey);
extern void softKeys_toLCD();
extern uint8_t softKey_MessageKey_ToSoftKeyNr(uint8_t messageKey);
extern uint8_t softKey_Execute(uint8_t nrSoftKey, uint8_t myMessage);





extern const char sw_version [] 
# 241 ".././menu.h" 3
                               __attribute__((__progmem__))
# 241 ".././menu.h"
                                      ;
extern const char HelloMsg [] 
# 242 ".././menu.h" 3
                             __attribute__((__progmem__))
# 242 ".././menu.h"
                                    ;

extern uint8_t menu_TestModulePattern;
extern uint8_t menu_TestModuleBitCounter;
extern uint32_t menu_TestModuleErrorList;

extern void menu_showPowerState();






void menu_Init(const __flash Menu_t* newMenu, const __flash char* pTitle);
extern void menu_InitLCD();
extern uint8_t menu_ProcessMessage(uint8_t message);
extern void menu_ClearAllDisp();

extern void menu_ModuleTestExecute();
extern uint8_t menu_OnEnterMidiPanic(uint8_t arg);
# 18 ".././menu.c" 2
# 1 ".././Midi.h" 1
# 44 ".././Midi.h"
typedef struct {
 uint8_t channel;
 uint8_t note;
} ChannelNote_t;

typedef struct {
 uint8_t manual;
 uint8_t note;
} ManualNote_t;

typedef struct {
 uint8_t moduleNr;
 uint8_t bitNr;
} ModuleBit_t;




typedef struct {
 uint8_t error;
 uint8_t moduleBit;
} ModulBitError_t;

typedef struct{
 uint8_t startNote;
 uint8_t endNote;
 uint8_t bitStart;
} ManualMap_t;
extern ManualMap_t manualMap[4][4];

typedef struct{
 uint8_t startNote;
 uint8_t endNote;
} ManualNoteRange_t;
extern ManualNoteRange_t ManualNoteRange[4];
# 115 ".././Midi.h"
typedef struct{
 uint8_t manual;
 uint8_t midiNote;
 uint8_t noteRange;
 uint8_t manualNote;
} MidiInMap_t;

extern MidiInMap_t midiInMap[16][4];

typedef struct{
 uint8_t channel;
 } MidiOutMap_t;
extern MidiOutMap_t midiOutMap[4];


typedef struct{
 uint8_t startReg;
 uint8_t endReg;
 uint8_t bitStart;
} RegisterMap_t;
extern RegisterMap_t registerMap[8];

extern uint8_t registerCount;
extern uint8_t programMap[64] [64 / 8];

extern void registers_CalcCount();
extern void register_toProgram(uint8_t program);
extern void program_toRegister(uint8_t program);

extern void init_Midi2Manual();
extern void init_Manual2Midi();
extern void init_Manual2Module();
extern void init_Registers();

extern void midiNote_to_Manual(uint8_t channel, uint8_t note, uint8_t onOff);
extern ChannelNote_t Manual_to_MidiNote(uint8_t manual, uint8_t note);
extern void Midi_updateManualRange();

extern void midiSendAllNotesOff();



extern uint8_t midiRxActivceSensing;
typedef struct {
 uint8_t TxActivceSense;
 uint8_t VelZero4Off;
} MidiSetting_t;
extern MidiSetting_t midi_Setting;

extern uint8_t midiLastOutNote;
extern uint8_t midiLastOutManual;
extern uint8_t midiLastInNote;
extern uint8_t midiLastInChannel;
extern uint8_t midiLastInManual;

extern void midiKeyPress_Process(PipeMessage_t pipeMessage);
extern void midiIn_Process(uint8_t midiByte);
extern void manual_NoteOnOff(uint8_t manual, uint8_t note, uint8_t onOff);
extern void program_toRegister(uint8_t program);
extern void midi_SendActiveSense();
extern void midi_CheckRxActiveSense();
extern void midi_CheckTxActiveSense();


extern void init_Midi();
extern void midi_ManualOff(uint8_t manual);
extern void midi_AllManualsOff();
# 198 ".././Midi.h"
extern uint8_t midi_Couplers[12];

typedef struct{
 uint8_t dest;
 uint8_t source;
} CplInfo_t;
extern const __flash CplInfo_t cplInfo[12];

extern uint8_t set_Coupler(uint8_t);


extern uint8_t midiCoupler_2from3;
extern uint8_t midiCoupler_1from3;
extern uint8_t midiCoupler_1from2;
extern uint8_t midiCoupler_Pfrom3;
extern uint8_t midiCoupler_Pfrom2;
extern uint8_t midiCoupler_Pfrom1;
extern uint8_t midiCoupler_3from2;
extern uint8_t midiCoupler_3from1;
extern uint8_t midiCoupler_2from1;
extern uint8_t midiCoupler_3fromP;
extern uint8_t midiCoupler_2fromP;
extern uint8_t midiCoupler_1fromP;
# 19 ".././menu.c" 2
# 1 ".././ee_prom.h" 1
# 11 ".././ee_prom.h"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 1 3
# 112 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3

# 112 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc16_update(uint16_t __crc, uint8_t __data)
{
 uint8_t __tmp;
 uint16_t __ret;

 __asm__ __volatile__ (
  "eor %A0,%2" "\n\t"
  "mov %1,%A0" "\n\t"
  "swap %1" "\n\t"
  "eor %1,%A0" "\n\t"
  "mov __tmp_reg__,%1" "\n\t"
  "lsr %1" "\n\t"
  "lsr %1" "\n\t"
  "eor %1,__tmp_reg__" "\n\t"
  "mov __tmp_reg__,%1" "\n\t"
  "lsr %1" "\n\t"
  "eor %1,__tmp_reg__" "\n\t"
  "andi %1,0x07" "\n\t"
  "mov __tmp_reg__,%A0" "\n\t"
  "mov %A0,%B0" "\n\t"
  "lsr %1" "\n\t"
  "ror __tmp_reg__" "\n\t"
  "ror %1" "\n\t"
  "mov %B0,__tmp_reg__" "\n\t"
  "eor %A0,%1" "\n\t"
  "lsr __tmp_reg__" "\n\t"
  "ror %1" "\n\t"
  "eor %B0,__tmp_reg__" "\n\t"
  "eor %A0,%1"
  : "=r" (__ret), "=d" (__tmp)
  : "r" (__data), "0" (__crc)
  : "r0"
 );
 return __ret;
}
# 178 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc_xmodem_update(uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;
    uint8_t __tmp1;
    uint8_t __tmp2;


    __asm__ __volatile__ (
        "eor    %B0,%3" "\n\t"
        "mov    __tmp_reg__,%B0" "\n\t"
        "swap   __tmp_reg__" "\n\t"


        "mov    %1,__tmp_reg__" "\n\t"
        "andi   %1,0x0f" "\n\t"
        "eor    %1,%B0" "\n\t"
        "mov    %2,%B0" "\n\t"
        "eor    %2,__tmp_reg__" "\n\t"
        "lsl    %2" "\n\t"
        "andi   %2,0xe0" "\n\t"
        "eor    %1,%2" "\n\t"


        "mov    %2,__tmp_reg__" "\n\t"
        "eor    %2,%B0" "\n\t"
        "andi   %2,0xf0" "\n\t"
        "lsr    %2" "\n\t"
        "mov    __tmp_reg__,%B0" "\n\t"
        "lsl    __tmp_reg__" "\n\t"
        "rol    %2" "\n\t"
        "lsr    %B0" "\n\t"
        "lsr    %B0" "\n\t"
        "lsr    %B0" "\n\t"
        "andi   %B0,0x1f" "\n\t"
        "eor    %B0,%2" "\n\t"
        "eor    %B0,%A0" "\n\t"
        "mov    %A0,%1" "\n\t"
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
# 252 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
        "eor    %A0,%1" "\n\t"

        "mov    __tmp_reg__,%A0" "\n\t"
        "swap   %A0" "\n\t"
        "andi   %A0,0xf0" "\n\t"
        "eor    %A0,__tmp_reg__" "\n\t"

        "mov    __tmp_reg__,%B0" "\n\t"

        "mov    %B0,%A0" "\n\t"

        "swap   %A0" "\n\t"
        "andi   %A0,0x0f" "\n\t"
        "eor    __tmp_reg__,%A0" "\n\t"

        "lsr    %A0" "\n\t"
        "eor    %B0,%A0" "\n\t"

        "eor    %A0,%B0" "\n\t"
        "lsl    %A0" "\n\t"
        "lsl    %A0" "\n\t"
        "lsl    %A0" "\n\t"
        "eor    %A0,__tmp_reg__"

        : "=d" (__ret)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
# 319 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint8_t
_crc_ibutton_update(uint8_t __crc, uint8_t __data)
{
 uint8_t __i, __pattern;
 __asm__ __volatile__ (
  "	eor	%0, %4" "\n\t"
  "	ldi	%1, 8" "\n\t"
  "	ldi	%2, 0x8C" "\n\t"
  "1:	lsr	%0" "\n\t"
  "	brcc	2f" "\n\t"
  "	eor	%0, %2" "\n\t"
  "2:	dec	%1" "\n\t"
  "	brne	1b" "\n\t"
  : "=r" (__crc), "=d" (__i), "=d" (__pattern)
  : "0" (__crc), "r" (__data));
 return __crc;
}
# 385 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint8_t
_crc8_ccitt_update(uint8_t __crc, uint8_t __data)
{
    uint8_t __i, __pattern;
    __asm__ __volatile__ (
        "    eor    %0, %4" "\n\t"
        "    ldi    %1, 8" "\n\t"
        "    ldi    %2, 0x07" "\n\t"
        "1:  lsl    %0" "\n\t"
        "    brcc   2f" "\n\t"
        "    eor    %0, %2" "\n\t"
        "2:  dec    %1" "\n\t"
        "    brne   1b" "\n\t"
        : "=r" (__crc), "=d" (__i), "=d" (__pattern)
        : "0" (__crc), "r" (__data));
    return __crc;
}
# 12 ".././ee_prom.h" 2
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\eeprom.h" 1 3
# 50 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\eeprom.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 1 3 4
# 51 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\eeprom.h" 2 3
# 139 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\eeprom.h" 3
uint8_t eeprom_read_byte (const uint8_t *__p) __attribute__((__pure__));




uint16_t eeprom_read_word (const uint16_t *__p) __attribute__((__pure__));




uint32_t eeprom_read_dword (const uint32_t *__p) __attribute__((__pure__));




float eeprom_read_float (const float *__p) __attribute__((__pure__));





void eeprom_read_block (void *__dst, const void *__src, size_t __n);





void eeprom_write_byte (uint8_t *__p, uint8_t __value);




void eeprom_write_word (uint16_t *__p, uint16_t __value);




void eeprom_write_dword (uint32_t *__p, uint32_t __value);




void eeprom_write_float (float *__p, float __value);





void eeprom_write_block (const void *__src, void *__dst, size_t __n);





void eeprom_update_byte (uint8_t *__p, uint8_t __value);




void eeprom_update_word (uint16_t *__p, uint16_t __value);




void eeprom_update_dword (uint32_t *__p, uint32_t __value);




void eeprom_update_float (float *__p, float __value);





void eeprom_update_block (const void *__src, void *__dst, size_t __n);
# 13 ".././ee_prom.h" 2



# 1 ".././menu.h" 1
# 17 ".././ee_prom.h" 2







# 23 ".././ee_prom.h"
extern uint8_t eeprom_ReadManualMap();
extern uint8_t eeprom_ReadMidiInMap();
extern uint8_t eeprom_ReadMidiOutMap();
extern uint8_t eeprom_ReadModules();
extern uint8_t eeprom_ReadUSB();
extern uint8_t eeprom_ReadReg();
extern uint8_t eeprom_ReadProg();
extern uint8_t eeprom_ReadSoftkeys();
extern void eeprom_UpdateManualMap();
extern void eeprom_UpdateMidiInMap();
extern void eeprom_UpdateMidiOutMap();
extern void eeprom_UpdateModules();
extern void eeprom_UpdateUSB();
extern void eeprom_UpdateReg();
extern void eeprom_UpdateProg();
extern void eeprom_UpdateSoftkeys();
extern void eeprom_Backup();
extern void eeprom_Restore();
extern void eeprom_UpdateALL();
# 56 ".././ee_prom.h"
typedef struct{
 uint8_t charStart;
 uint8_t charManMap;
 ManualMap_t manualMap[4][4];
 uint16_t manualMap_crc;
 uint8_t charMidiInMap;
 MidiInMap_t midiInMap[16][4];
 uint16_t midiInMap_crc;
 uint8_t charMidiOutMap;
 MidiOutMap_t midiOutMap[4];
 MidiSetting_t midiSettings;
 uint16_t midiOutMap_crc;
 uint8_t charModInst;
 uint8_t moduleAssignRead;
 uint8_t moduleAssignWrite;
 uint16_t moduleInstalled_crc;
 uint8_t charUSB;
 uint8_t usbActive;
 uint16_t usb_crc;
 uint8_t charReg;
 uint8_t regCount;
 RegisterMap_t registerMap[8];
 uint16_t reg_crc;
 uint8_t charProg;
 uint8_t programMap[64] [64 / 8];
 uint16_t prog_crc;
 uint8_t charSoftkey;
 uint8_t softKeyMenuIndex[4];
 uint16_t softKeys_crc;
 uint8_t charEnd;
} Ee_t;



typedef union{
 Ee_t ee;
 uint8_t raw[1024];
} EEblock_t;

typedef struct{
 EEblock_t eeData;
 EEblock_t eeBackup;
} EECompl_t;

extern 
# 100 ".././ee_prom.h" 3
      __attribute__((section(".eeprom"))) 
# 100 ".././ee_prom.h"
            EECompl_t ee;
# 112 ".././ee_prom.h"
extern uint8_t ee_initError;
# 20 ".././menu.c" 2
# 1 ".././log.h" 1
# 12 ".././log.h"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ctype.h" 1 3
# 74 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ctype.h" 3

# 74 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ctype.h" 3
extern int isalnum(int __c) __attribute__((__const__));






extern int isalpha(int __c) __attribute__((__const__));






extern int isascii(int __c) __attribute__((__const__));





extern int isblank(int __c) __attribute__((__const__));





extern int iscntrl(int __c) __attribute__((__const__));





extern int isdigit(int __c) __attribute__((__const__));





extern int isgraph(int __c) __attribute__((__const__));





extern int islower(int __c) __attribute__((__const__));





extern int isprint(int __c) __attribute__((__const__));






extern int ispunct(int __c) __attribute__((__const__));







extern int isspace(int __c) __attribute__((__const__));





extern int isupper(int __c) __attribute__((__const__));






extern int isxdigit(int __c) __attribute__((__const__));
# 173 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ctype.h" 3
extern int toascii(int __c) __attribute__((__const__));





extern int tolower(int __c) __attribute__((__const__));





extern int toupper(int __c) __attribute__((__const__));
# 13 ".././log.h" 2
# 28 ".././log.h"

# 28 ".././log.h"
typedef struct {
 uint8_t uptime[4];
 uint8_t logStatus;
 uint8_t logType;
 uint8_t logCategory;
 uint8_t logNr;
 uint16_t logInfo;
} LogList_t;

extern LogList_t log_List[40];

typedef struct {
 uint8_t logCategory;
 uint8_t logNr;
 uint16_t logInfo;
} Log_t;

extern char Log_TextBuff[40];



void init_log();
void log_putError(uint8_t LogCat, uint8_t LogNr, uint16_t LogInfo);
void log_putWarning(uint8_t LogCat, uint8_t LogNr, uint16_t LogInfo);
void log_putInfo(uint8_t LogCat, uint8_t LogNr, uint16_t LogInfo);
void log_put(uint8_t LogCat, uint8_t LogNr, uint16_t LogInfo, uint8_t logType);
uint8_t log_count();
LogList_t* log_getLog(uint8_t nr);
char* log_getShortTextFromIndex(uint8_t nr, char changeNotifyStatus);
char* log_getShortTextFromPtr(LogList_t* pLogEntry, char changeNotifyStatus);
const __flash char* getErrorText(uint8_t logNr);


typedef struct{
 uint8_t errCat;
 uint8_t errNr;
 char text[16];
 } ErrorText_t;
# 88 ".././log.h"
extern uint8_t log_unreadErrors;
# 21 ".././menu.c" 2



const char sw_version [] 
# 24 ".././menu.c" 3
                        __attribute__((__progmem__)) 
# 24 ".././menu.c"
                                = "V0.57";

uint8_t menuOnExitMidiChannelSection(uint8_t arg);
uint8_t menuOnExitManualSection(uint8_t arg);
uint8_t menuOnEnterStatusMidiOut(uint8_t arg);
uint8_t menuOnEnterStatusMidiIn(uint8_t arg);
uint8_t menuOnEnterLogDisp(uint8_t arg);


const __flash Menu_t menu_status[] =
 {{1 | 0x80,0x20,"Log",
# 34 ".././menu.c" 3 4
                                                                 ((void *)0)
# 34 ".././menu.c"
                                                                     ,{
# 34 ".././menu.c" 3 4
                                                                       ((void *)0)
# 34 ".././menu.c"
                                                                           },menuOnEnterLogDisp,
# 34 ".././menu.c" 3 4
                                                                                                ((void *)0)
# 34 ".././menu.c"
                                                                                                    },
 {2,0x40,"MIDI-In",
# 35 ".././menu.c" 3 4
                                               ((void *)0)
# 35 ".././menu.c"
                                                   ,{
# 35 ".././menu.c" 3 4
                                                     ((void *)0)
# 35 ".././menu.c"
                                                         },menuOnEnterStatusMidiIn,
# 35 ".././menu.c" 3 4
                                                                                   ((void *)0)
# 35 ".././menu.c"
                                                                                       },
 {2 | 0xC0,0x40,"MIDI-Out",
# 36 ".././menu.c" 3 4
                                                                    ((void *)0)
# 36 ".././menu.c"
                                                                        ,{
# 36 ".././menu.c" 3 4
                                                                          ((void *)0)
# 36 ".././menu.c"
                                                                              },menuOnEnterStatusMidiOut,
# 36 ".././menu.c" 3 4
                                                                                                         ((void *)0)
# 36 ".././menu.c"
                                                                                                             }};


const __flash Menu_t menu_modDefine[] =
 {{4 | 0x80,0x80 | 0x10,"NoteBeg",
# 40 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 40 ".././menu.c"
                                                                                               ,{&(manualMap[0][0].startNote)},
# 40 ".././menu.c" 3 4
                                                                                                                               ((void *)0)
# 40 ".././menu.c"
                                                                                                                                   ,
# 40 ".././menu.c" 3 4
                                                                                                                                    ((void *)0)
# 40 ".././menu.c"
                                                                                                                                        },
 {4,0x80 | 0x10,"NoteEnd",
# 41 ".././menu.c" 3 4
                                                                       ((void *)0)
# 41 ".././menu.c"
                                                                           ,{&(manualMap[0][0].endNote)},
# 41 ".././menu.c" 3 4
                                                                                                         ((void *)0)
# 41 ".././menu.c"
                                                                                                             ,
# 41 ".././menu.c" 3 4
                                                                                                              ((void *)0)
# 41 ".././menu.c"
                                                                                                                  },
 {5 | 0xC0,0x80,"Module/Bit",
# 42 ".././menu.c" 3 4
                                                                        ((void *)0)
# 42 ".././menu.c"
                                                                            ,{&(manualMap[0][0].bitStart)},
# 42 ".././menu.c" 3 4
                                                                                                           ((void *)0)
# 42 ".././menu.c"
                                                                                                               ,
# 42 ".././menu.c" 3 4
                                                                                                                ((void *)0)
# 42 ".././menu.c"
                                                                                                                    }};

const __flash Menu_t menu_modDefineReg[] = {
 {13 | 0x80,0x80,"RegBeg",
# 45 ".././menu.c" 3 4
                                                                ((void *)0)
# 45 ".././menu.c"
                                                                    ,{&(registerMap[0].startReg)},
# 45 ".././menu.c" 3 4
                                                                                                  ((void *)0)
# 45 ".././menu.c"
                                                                                                      ,
# 45 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 45 ".././menu.c"
                                                                                                           },
 {13,0x80,"RegEnd",
# 46 ".././menu.c" 3 4
                                             ((void *)0)
# 46 ".././menu.c"
                                                 ,{&(registerMap[0].endReg)},
# 46 ".././menu.c" 3 4
                                                                             ((void *)0)
# 46 ".././menu.c"
                                                                                 ,
# 46 ".././menu.c" 3 4
                                                                                  ((void *)0)
# 46 ".././menu.c"
                                                                                      },
 {5 | 0xC0,0x80,"Module/Bit",
# 47 ".././menu.c" 3 4
                                                                        ((void *)0)
# 47 ".././menu.c"
                                                                            ,{&(registerMap[0].bitStart)},
# 47 ".././menu.c" 3 4
                                                                                                          ((void *)0)
# 47 ".././menu.c"
                                                                                                              ,
# 47 ".././menu.c" 3 4
                                                                                                               ((void *)0)
# 47 ".././menu.c"
                                                                                                                   }
};


uint8_t menuOnEnterModSec(uint8_t arg);
const __flash Menu_t menu_modSection[] =
 {{(1 | 0x80),0,"Sect.1",menu_modDefine,{.tag=0},menuOnEnterModSec,
# 53 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 53 ".././menu.c"
                                                                                          },
 {1,0,"Sect.2",menu_modDefine,{.tag= 1},menuOnEnterModSec,
# 54 ".././menu.c" 3 4
                                                                                    ((void *)0)
# 54 ".././menu.c"
                                                                                        },
 {1,0,"Sect.3",menu_modDefine,{.tag=2},menuOnEnterModSec,
# 55 ".././menu.c" 3 4
                                                                                   ((void *)0)
# 55 ".././menu.c"
                                                                                       },
 {(1 | 0xC0),0,"Sect.4",menu_modDefine,{.tag=3},menuOnEnterModSec,
# 56 ".././menu.c" 3 4
                                                                                     ((void *)0)
# 56 ".././menu.c"
                                                                                         }};

uint8_t menuOnEnterModSecReg(uint8_t arg);
const __flash Menu_t menu_modSection8[] = {
 {(1 | 0x80),0,"Sect.1",menu_modDefineReg,{.tag=0},menuOnEnterModSecReg,
# 60 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 60 ".././menu.c"
                                                                                               },
 {1,0,"Sect.2",menu_modDefineReg,{.tag= 1},menuOnEnterModSecReg,
# 61 ".././menu.c" 3 4
                                                                                          ((void *)0)
# 61 ".././menu.c"
                                                                                              },
 {1,0,"Sect.3",menu_modDefineReg,{.tag=2},menuOnEnterModSecReg,
# 62 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 62 ".././menu.c"
                                                                                             },
 {1,0,"Sect.4",menu_modDefineReg,{.tag=3},menuOnEnterModSecReg,
# 63 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 63 ".././menu.c"
                                                                                             },
 {1,0,"Sect.5",menu_modDefineReg,{.tag=4},menuOnEnterModSecReg,
# 64 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 64 ".././menu.c"
                                                                                             },
 {1,0,"Sect.6",menu_modDefineReg,{.tag=5},menuOnEnterModSecReg,
# 65 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 65 ".././menu.c"
                                                                                             },
 {1,0,"Sect.7",menu_modDefineReg,{.tag=6},menuOnEnterModSecReg,
# 66 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 66 ".././menu.c"
                                                                                             },
 {(1 | 0xC0),0,"Sect.8",menu_modDefineReg,{.tag=7},menuOnEnterModSecReg,
# 67 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 67 ".././menu.c"
                                                                                               }
};


uint8_t menuOnEnterModManual(uint8_t arg);
const __flash Menu_t menu_modAssign[] =
 {{(1 | 0x80),0,"Man.3",menu_modSection,{.tag=0},menuOnEnterModManual,
# 73 ".././menu.c" 3 4
                                                                                       ((void *)0)
# 73 ".././menu.c"
                                                                                           },
 {1,0,"Man.2",menu_modSection,{.tag=1},menuOnEnterModManual,
# 74 ".././menu.c" 3 4
                                                                                   ((void *)0)
# 74 ".././menu.c"
                                                                                       },
 {1,0,"Man.1",menu_modSection,{.tag=2},menuOnEnterModManual,
# 75 ".././menu.c" 3 4
                                                                                  ((void *)0)
# 75 ".././menu.c"
                                                                                      },
 {1,0,"Pedal",menu_modSection,{.tag=3},menuOnEnterModManual,
# 76 ".././menu.c" 3 4
                                                                                  ((void *)0)
# 76 ".././menu.c"
                                                                                      },
 {(1 | 0xC0),0,"Register",menu_modSection8,{.tag=4},
# 77 ".././menu.c" 3 4
                                                                ((void *)0)
# 77 ".././menu.c"
                                                                    ,
# 77 ".././menu.c" 3 4
                                                                     ((void *)0)
# 77 ".././menu.c"
                                                                         }
};


uint8_t menuOnEnterUSBprotokoll(uint8_t arg);
uint8_t menuOnExitUSBactive(uint8_t arg);
uint8_t menuOnEnterUSBsendHW(uint8_t arg);
const __flash Menu_t menu_USBser[] =
 {{9 | 0x80,0,"Active",
# 85 ".././menu.c" 3 4
                                                ((void *)0)
# 85 ".././menu.c"
                                                    ,{(uint8_t *) &(serusb_Active)},
# 85 ".././menu.c" 3 4
                                                                                    ((void *)0)
# 85 ".././menu.c"
                                                                                        ,menuOnExitUSBactive},
 {1,0,"SendLog",
# 86 ".././menu.c" 3 4
                         ((void *)0)
# 86 ".././menu.c"
                             ,{
# 86 ".././menu.c" 3 4
                               ((void *)0)
# 86 ".././menu.c"
                                   },menuOnEnterUSBprotokoll,
# 86 ".././menu.c" 3 4
                                                             ((void *)0)
# 86 ".././menu.c"
                                                                 },
 {1 | 0xC0,0,"SndHWCfg",
# 87 ".././menu.c" 3 4
                                              ((void *)0)
# 87 ".././menu.c"
                                                  ,{
# 87 ".././menu.c" 3 4
                                                    ((void *)0)
# 87 ".././menu.c"
                                                        },menuOnEnterUSBsendHW,
# 87 ".././menu.c" 3 4
                                                                               ((void *)0)
# 87 ".././menu.c"
                                                                                   }};


uint8_t menu_ModuleTestPattern(uint8_t arg);
uint8_t menu_testModule(uint8_t arg);
uint8_t menu_readModule(uint8_t arg);
uint8_t menu_enterWriteModule(uint8_t arg);
uint8_t menu_exitWriteModule(uint8_t arg);
const __flash Menu_t menu_ModTestSelcted[] =
{{1 | 0x80,0,"Read",
# 96 ".././menu.c" 3 4
                                         ((void *)0)
# 96 ".././menu.c"
                                             ,{
# 96 ".././menu.c" 3 4
                                               ((void *)0)
# 96 ".././menu.c"
                                                   },menu_readModule,
# 96 ".././menu.c" 3 4
                                                                     ((void *)0)
# 96 ".././menu.c"
                                                                         },
{11,0,"Write",
# 97 ".././menu.c" 3 4
                         ((void *)0)
# 97 ".././menu.c"
                             ,{(uint8_t *)&menuModVal},menu_enterWriteModule,menu_exitWriteModule},
{1,0,"TestPtrn",
# 98 ".././menu.c" 3 4
                         ((void *)0)
# 98 ".././menu.c"
                             ,{
# 98 ".././menu.c" 3 4
                               ((void *)0)
# 98 ".././menu.c"
                                   },menu_ModuleTestPattern,
# 98 ".././menu.c" 3 4
                                                            ((void *)0)
# 98 ".././menu.c"
                                                                },
{1 | 0xC0,0,"LoopTst",
# 99 ".././menu.c" 3 4
                                            ((void *)0)
# 99 ".././menu.c"
                                                ,{
# 99 ".././menu.c" 3 4
                                                  ((void *)0)
# 99 ".././menu.c"
                                                      },menu_testModule,
# 99 ".././menu.c" 3 4
                                                                        ((void *)0)
# 99 ".././menu.c"
                                                                            }};


uint8_t menuOnEnterModSel(uint8_t arg);
const __flash Menu_t menu_ModeSel[] =
 {{(1 | 0x80),0,"Mod.0",menu_ModTestSelcted,{.tag=0},menuOnEnterModSel,
# 104 ".././menu.c" 3 4
                                                                               ((void *)0)
# 104 ".././menu.c"
                                                                                   },
 {1,0,"Mod.1",menu_ModTestSelcted,{.tag=1},menuOnEnterModSel,
# 105 ".././menu.c" 3 4
                                                                            ((void *)0)
# 105 ".././menu.c"
                                                                                },
 {1,0,"Mod.2",menu_ModTestSelcted,{.tag=2},menuOnEnterModSel,
# 106 ".././menu.c" 3 4
                                                                            ((void *)0)
# 106 ".././menu.c"
                                                                                },
 {1,0,"Mod.3",menu_ModTestSelcted,{.tag=3},menuOnEnterModSel,
# 107 ".././menu.c" 3 4
                                                                            ((void *)0)
# 107 ".././menu.c"
                                                                                },
 {1,0,"Mod.4",menu_ModTestSelcted,{.tag=4},menuOnEnterModSel,
# 108 ".././menu.c" 3 4
                                                                            ((void *)0)
# 108 ".././menu.c"
                                                                                },
 {1,0,"Mod.5",menu_ModTestSelcted,{.tag=5},menuOnEnterModSel,
# 109 ".././menu.c" 3 4
                                                                            ((void *)0)
# 109 ".././menu.c"
                                                                                },
 {1,0,"Mod.6",menu_ModTestSelcted,{.tag=6},menuOnEnterModSel,
# 110 ".././menu.c" 3 4
                                                                            ((void *)0)
# 110 ".././menu.c"
                                                                                },
 {(1 | 0xC0),0,"Mod.7",menu_ModTestSelcted,{.tag=7},menuOnEnterModSel,
# 111 ".././menu.c" 3 4
                                                                              ((void *)0)
# 111 ".././menu.c"
                                                                                  }};


uint8_t menuOnExitModules(uint8_t arg);
uint8_t menuOnExitManual(uint8_t arg);
const __flash Menu_t menu_module[] =
 {{10 | 0x80,0,"ModRead",
# 117 ".././menu.c" 3 4
                                               ((void *)0)
# 117 ".././menu.c"
                                                   ,{&(pipe_ModuleAssnRead)},
# 117 ".././menu.c" 3 4
                                                                             ((void *)0)
# 117 ".././menu.c"
                                                                                 ,menuOnExitModules},
 {10,0,"ModWrite",
# 118 ".././menu.c" 3 4
                            ((void *)0)
# 118 ".././menu.c"
                                ,{&(pipe_ModuleAssnWrite)},
# 118 ".././menu.c" 3 4
                                                           ((void *)0)
# 118 ".././menu.c"
                                                               ,menuOnExitModules},
 {10,0x08,"ModOK",
# 119 ".././menu.c" 3 4
                                          ((void *)0)
# 119 ".././menu.c"
                                              ,{&(pipe_ModuleTested)},
# 119 ".././menu.c" 3 4
                                                                      ((void *)0)
# 119 ".././menu.c"
                                                                          ,
# 119 ".././menu.c" 3 4
                                                                           ((void *)0)
# 119 ".././menu.c"
                                                                               },
 {1,0,"ModTest",menu_ModeSel,{
# 120 ".././menu.c" 3 4
                                       ((void *)0)
# 120 ".././menu.c"
                                           },
# 120 ".././menu.c" 3 4
                                             ((void *)0)
# 120 ".././menu.c"
                                                 ,
# 120 ".././menu.c" 3 4
                                                  ((void *)0)
# 120 ".././menu.c"
                                                      },
 {(1 | 0xC0),0,"ModAssign",menu_modAssign,{
# 121 ".././menu.c" 3 4
                                             ((void *)0)
# 121 ".././menu.c"
                                                 },
# 121 ".././menu.c" 3 4
                                                   ((void *)0)
# 121 ".././menu.c"
                                                       ,menuOnExitManual}};


uint8_t menuOnEnterPwrOn(uint8_t arg);
uint8_t menuOnEnterPwrOff(uint8_t arg);
uint8_t menuOnEnterPwrRest(uint8_t arg);
const __flash Menu_t menu_Power[] =
{{(1 | 0x80),0,"PowerOn",
# 128 ".././menu.c" 3 4
                           ((void *)0)
# 128 ".././menu.c"
                               ,{
# 128 ".././menu.c" 3 4
                                 ((void *)0)
# 128 ".././menu.c"
                                     },menuOnEnterPwrOn,
# 128 ".././menu.c" 3 4
                                                        ((void *)0)
# 128 ".././menu.c"
                                                            },
{1,0,"PowerOff",
# 129 ".././menu.c" 3 4
                         ((void *)0)
# 129 ".././menu.c"
                             ,{
# 129 ".././menu.c" 3 4
                               ((void *)0)
# 129 ".././menu.c"
                                   },menuOnEnterPwrOff,
# 129 ".././menu.c" 3 4
                                                       ((void *)0)
# 129 ".././menu.c"
                                                           },
{(1 | 0xC0),0,"P.Restart",
# 130 ".././menu.c" 3 4
                            ((void *)0)
# 130 ".././menu.c"
                                ,{
# 130 ".././menu.c" 3 4
                                  ((void *)0)
# 130 ".././menu.c"
                                      },menuOnEnterPwrRest,
# 130 ".././menu.c" 3 4
                                                           ((void *)0)
# 130 ".././menu.c"
                                                               }};


uint8_t menuOnEnterEERestore(uint8_t arg);
uint8_t menuOnEnterEEBackup(uint8_t arg);
uint8_t menuOnEnterEEUpdate(uint8_t arg);
const __flash Menu_t menu_eeprom[] =
{{(1 | 0x80),0,"EESave",
# 137 ".././menu.c" 3 4
                          ((void *)0)
# 137 ".././menu.c"
                              ,{
# 137 ".././menu.c" 3 4
                                ((void *)0)
# 137 ".././menu.c"
                                    },menuOnEnterEEUpdate,
# 137 ".././menu.c" 3 4
                                                          ((void *)0)
# 137 ".././menu.c"
                                                              },
{1,0,"EEBackup",
# 138 ".././menu.c" 3 4
                         ((void *)0)
# 138 ".././menu.c"
                             ,{
# 138 ".././menu.c" 3 4
                               ((void *)0)
# 138 ".././menu.c"
                                   },menuOnEnterEEBackup,
# 138 ".././menu.c" 3 4
                                                         ((void *)0)
# 138 ".././menu.c"
                                                             },
{(1 | 0xC0),0,"EERestore",
# 139 ".././menu.c" 3 4
                            ((void *)0)
# 139 ".././menu.c"
                                ,{
# 139 ".././menu.c" 3 4
                                  ((void *)0)
# 139 ".././menu.c"
                                      },menuOnEnterEERestore,
# 139 ".././menu.c" 3 4
                                                             ((void *)0)
# 139 ".././menu.c"
                                                                 }};


const __flash Menu_t menu_setup[] =
{{(1 | 0x80),0,"Module",menu_module,{
# 143 ".././menu.c" 3 4
                                       ((void *)0)
# 143 ".././menu.c"
                                           },
# 143 ".././menu.c" 3 4
                                             ((void *)0)
# 143 ".././menu.c"
                                                 ,
# 143 ".././menu.c" 3 4
                                                  ((void *)0)
# 143 ".././menu.c"
                                                      },
{1,0,"USB",menu_USBser,{
# 144 ".././menu.c" 3 4
                                 ((void *)0)
# 144 ".././menu.c"
                                     },
# 144 ".././menu.c" 3 4
                                       ((void *)0)
# 144 ".././menu.c"
                                           ,
# 144 ".././menu.c" 3 4
                                            ((void *)0)
# 144 ".././menu.c"
                                                },
{1,0,"Power",menu_Power,{
# 145 ".././menu.c" 3 4
                                  ((void *)0)
# 145 ".././menu.c"
                                      },
# 145 ".././menu.c" 3 4
                                        ((void *)0)
# 145 ".././menu.c"
                                            ,
# 145 ".././menu.c" 3 4
                                             ((void *)0)
# 145 ".././menu.c"
                                                 },
{(1 | 0xC0),0,"EEprom",menu_eeprom,{
# 146 ".././menu.c" 3 4
                                      ((void *)0)
# 146 ".././menu.c"
                                          },
# 146 ".././menu.c" 3 4
                                            ((void *)0)
# 146 ".././menu.c"
                                                ,
# 146 ".././menu.c" 3 4
                                                 ((void *)0)
# 146 ".././menu.c"
                                                     }};


const __flash Menu_t menu_midiOut[] =
 {{3 | 0x80,0x10,"III",
# 150 ".././menu.c" 3 4
                                                                    ((void *)0)
# 150 ".././menu.c"
                                                                        ,{&(midiOutMap[0].channel)},
# 150 ".././menu.c" 3 4
                                                                                                             ((void *)0)
# 150 ".././menu.c"
                                                                                                                 ,
# 150 ".././menu.c" 3 4
                                                                                                                  ((void *)0)
# 150 ".././menu.c"
                                                                                                                      },
 {3,0x10,"II",
# 151 ".././menu.c" 3 4
                                               ((void *)0)
# 151 ".././menu.c"
                                                   ,{&(midiOutMap[1].channel)},
# 151 ".././menu.c" 3 4
                                                                                       ((void *)0)
# 151 ".././menu.c"
                                                                                           ,
# 151 ".././menu.c" 3 4
                                                                                            ((void *)0)
# 151 ".././menu.c"
                                                                                                },
 {3,0x10,"I",
# 152 ".././menu.c" 3 4
                                              ((void *)0)
# 152 ".././menu.c"
                                                  ,{&(midiOutMap[2].channel)},
# 152 ".././menu.c" 3 4
                                                                                     ((void *)0)
# 152 ".././menu.c"
                                                                                         ,
# 152 ".././menu.c" 3 4
                                                                                          ((void *)0)
# 152 ".././menu.c"
                                                                                              },
 {3 | 0xC0,0x10,"P",
# 153 ".././menu.c" 3 4
                                                                   ((void *)0)
# 153 ".././menu.c"
                                                                       ,{&(midiOutMap[3].channel)},
# 153 ".././menu.c" 3 4
                                                                                                          ((void *)0)
# 153 ".././menu.c"
                                                                                                              ,
# 153 ".././menu.c" 3 4
                                                                                                               ((void *)0)
# 153 ".././menu.c"
                                                                                                                   }};

uint8_t menuOnEnterTestManual(uint8_t arg);
uint8_t menuOnExitTestManualMan(uint8_t arg);


uint8_t menuOnEnterTune(uint8_t arg);
const __flash Menu_t menu_tune[] =
 {{(1 | 0x80),0x20,"Man.3",
# 161 ".././menu.c" 3 4
                                                        ((void *)0)
# 161 ".././menu.c"
                                                            ,{.tag=0},menuOnEnterTune,
# 161 ".././menu.c" 3 4
                                                                                               ((void *)0)
# 161 ".././menu.c"
                                                                                                   },
 {1,0x20,"Man.2",
# 162 ".././menu.c" 3 4
                                                     ((void *)0)
# 162 ".././menu.c"
                                                         ,{.tag=1},menuOnEnterTune,
# 162 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 162 ".././menu.c"
                                                                                               },
 {1,0x20,"Man.1",
# 163 ".././menu.c" 3 4
                                                     ((void *)0)
# 163 ".././menu.c"
                                                         ,{.tag=2},menuOnEnterTune,
# 163 ".././menu.c" 3 4
                                                                                          ((void *)0)
# 163 ".././menu.c"
                                                                                              },
 {(1 | 0xC0),0x20,"Pedal",
# 164 ".././menu.c" 3 4
                                                       ((void *)0)
# 164 ".././menu.c"
                                                           ,{.tag=3},menuOnEnterTune,
# 164 ".././menu.c" 3 4
                                                                                            ((void *)0)
# 164 ".././menu.c"
                                                                                                }};


extern const __flash Menu_t menu_selFunc[];
uint8_t menuOnExitKey(uint8_t arg);
uint8_t menuOnEnterKey(uint8_t arg);
const __flash Menu_t menu_key[] =
{{(1 | 0x80), 0x08,"Taste1",menu_selFunc,{.tag=0},menuOnEnterKey,menuOnExitKey},
{1,0x08,"Taste2",menu_selFunc,{.tag=1},menuOnEnterKey,menuOnExitKey},
{1,0x08,"Taste3",menu_selFunc,{.tag=2},menuOnEnterKey,menuOnExitKey},
{(1 | 0xC0),0x08,"Taste4",menu_selFunc,{.tag=3},menuOnEnterKey,menuOnExitKey}};


const __flash Menu_t menu_midiInVar[] =
{{7 | 0x80,0x80 | 0x10,"Manual",
# 178 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 178 ".././menu.c"
                                                                                               ,{&(midiInMap[0][0].manual)},
# 178 ".././menu.c" 3 4
                                                                                                                            ((void *)0)
# 178 ".././menu.c"
                                                                                                                                ,
# 178 ".././menu.c" 3 4
                                                                                                                                 ((void *)0)
# 178 ".././menu.c"
                                                                                                                                     },
{4,0x80 | 0x10,"MidNote",
# 179 ".././menu.c" 3 4
                                                                      ((void *)0)
# 179 ".././menu.c"
                                                                          ,{&(midiInMap[0][0].midiNote)},
# 179 ".././menu.c" 3 4
                                                                                                         ((void *)0)
# 179 ".././menu.c"
                                                                                                             ,
# 179 ".././menu.c" 3 4
                                                                                                              ((void *)0)
# 179 ".././menu.c"
                                                                                                                  },
{6,0x80,"Range",
# 180 ".././menu.c" 3 4
                                           ((void *)0)
# 180 ".././menu.c"
                                               ,{&(midiInMap[0][0].noteRange)},
# 180 ".././menu.c" 3 4
                                                                               ((void *)0)
# 180 ".././menu.c"
                                                                                   ,
# 180 ".././menu.c" 3 4
                                                                                    ((void *)0)
# 180 ".././menu.c"
                                                                                        },
{4 | 0xC0,0x80 | 0x10,"ManNote",
# 181 ".././menu.c" 3 4
                                                                                          ((void *)0)
# 181 ".././menu.c"
                                                                                              ,{&(midiInMap[0][0].manualNote)},
# 181 ".././menu.c" 3 4
                                                                                                                               ((void *)0)
# 181 ".././menu.c"
                                                                                                                                   ,
# 181 ".././menu.c" 3 4
                                                                                                                                    ((void *)0)
# 181 ".././menu.c"
                                                                                                                                        }};


uint8_t menuOnEnterMidiInSec(uint8_t arg);
const __flash Menu_t menu_midiInSec[] =
 {{(1 | 0x80),0,"Sect.1",menu_midiInVar,{.tag=0},menuOnEnterMidiInSec,
# 186 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 186 ".././menu.c"
                                                                                             },
 {1,0,"Sect.2",menu_midiInVar,{.tag=1},menuOnEnterMidiInSec,
# 187 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 187 ".././menu.c"
                                                                                          },
 {1,0,"Sect.3",menu_midiInVar,{.tag=2},menuOnEnterMidiInSec,
# 188 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 188 ".././menu.c"
                                                                                          },
 {(1 | 0xC0),0,"Sect.4",menu_midiInVar,{.tag=3},menuOnEnterMidiInSec,
# 189 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 189 ".././menu.c"
                                                                                            }};


uint8_t menuOnEnterMidiInCh(uint8_t arg);
const __flash Menu_t menu_midiIn[] =
 {{(1 | 0x80),0,"Ch.1",menu_midiInSec,{.tag = 0},menuOnEnterMidiInCh,
# 194 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 194 ".././menu.c"
                                                                                               },
 {1,0,"Ch.2",menu_midiInSec,{.tag=1},menuOnEnterMidiInCh,
# 195 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 195 ".././menu.c"
                                                                                          },
 {1,0,"Ch.3",menu_midiInSec,{.tag=2},menuOnEnterMidiInCh,
# 196 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 196 ".././menu.c"
                                                                                          },
 {1,0,"Ch.4",menu_midiInSec,{.tag=3},menuOnEnterMidiInCh,
# 197 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 197 ".././menu.c"
                                                                                          },
 {1,0,"Ch.5",menu_midiInSec,{.tag=4},menuOnEnterMidiInCh,
# 198 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 198 ".././menu.c"
                                                                                          },
 {1,0,"Ch.6",menu_midiInSec,{.tag=5},menuOnEnterMidiInCh,
# 199 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 199 ".././menu.c"
                                                                                          },
 {1,0,"Ch.7",menu_midiInSec,{.tag=6},menuOnEnterMidiInCh,
# 200 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 200 ".././menu.c"
                                                                                          },
 {1,0,"Ch.8",menu_midiInSec,{.tag=7},menuOnEnterMidiInCh,
# 201 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 201 ".././menu.c"
                                                                                          },
 {1,0,"Ch.9",menu_midiInSec,{.tag=8},menuOnEnterMidiInCh,
# 202 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 202 ".././menu.c"
                                                                                          },
 {1,0,"Ch.10",menu_midiInSec,{.tag=9},menuOnEnterMidiInCh,
# 203 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 203 ".././menu.c"
                                                                                            },
 {1,0,"Ch.11",menu_midiInSec,{.tag=10},menuOnEnterMidiInCh,
# 204 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 204 ".././menu.c"
                                                                                            },
 {1,0,"Ch.12",menu_midiInSec,{.tag=11},menuOnEnterMidiInCh,
# 205 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 205 ".././menu.c"
                                                                                            },
 {1,0,"Ch.13",menu_midiInSec,{.tag=12},menuOnEnterMidiInCh,
# 206 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 206 ".././menu.c"
                                                                                            },
 {1,0,"Ch.14",menu_midiInSec,{.tag=13},menuOnEnterMidiInCh,
# 207 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 207 ".././menu.c"
                                                                                            },
 {1,0,"Ch.15",menu_midiInSec,{.tag=14},menuOnEnterMidiInCh,
# 208 ".././menu.c" 3 4
                                                                                        ((void *)0)
# 208 ".././menu.c"
                                                                                            },
 {(1 | 0xC0),0,"Ch.16",menu_midiInSec,{.tag=15},menuOnEnterMidiInCh,
# 209 ".././menu.c" 3 4
                                                                                          ((void *)0)
# 209 ".././menu.c"
                                                                                              }};


uint8_t menuOnExitMidiIn(uint8_t arg);
uint8_t menuOnExitMidiOut(uint8_t arg);
uint8_t menu_OnEnterMidiPanic(uint8_t arg);
uint8_t menuOnExitMidiActiveSense(uint8_t arg);
const __flash Menu_t menu_midi[] =
 {{(1 | 0x80),0,"NotesOff",
# 217 ".././menu.c" 3 4
                             ((void *)0)
# 217 ".././menu.c"
                                 ,{
# 217 ".././menu.c" 3 4
                                   ((void *)0)
# 217 ".././menu.c"
                                       },menu_OnEnterMidiPanic,
# 217 ".././menu.c" 3 4
                                                               ((void *)0)
# 217 ".././menu.c"
                                                                   },
 {1,0,"MIDIin",menu_midiIn,{
# 218 ".././menu.c" 3 4
                                     ((void *)0)
# 218 ".././menu.c"
                                         },
# 218 ".././menu.c" 3 4
                                           ((void *)0)
# 218 ".././menu.c"
                                               ,menuOnExitMidiIn},
 {1,0,"MIDIout",menu_midiOut,{
# 219 ".././menu.c" 3 4
                                       ((void *)0)
# 219 ".././menu.c"
                                           },
# 219 ".././menu.c" 3 4
                                             ((void *)0)
# 219 ".././menu.c"
                                                 ,menuOnExitMidiOut},
 {9,0,"Act.Sense",
# 220 ".././menu.c" 3 4
                               ((void *)0)
# 220 ".././menu.c"
                                   ,{&(midi_Setting.TxActivceSense)},
# 220 ".././menu.c" 3 4
                                                                     ((void *)0)
# 220 ".././menu.c"
                                                                         ,menuOnExitMidiActiveSense},
 {9 | 0xC0,0,"Vel04Off",
# 221 ".././menu.c" 3 4
                                                  ((void *)0)
# 221 ".././menu.c"
                                                      ,{&(midi_Setting.VelZero4Off)},
# 221 ".././menu.c" 3 4
                                                                                     ((void *)0)
# 221 ".././menu.c"
                                                                                         ,menuOnExitMidiActiveSense}};


uint8_t menuOnExitCoupler(uint8_t arg);
const __flash Menu_t menu_coupler[] = {
 {9 | 0x80,0,"2<3",
# 226 ".././menu.c" 3 4
                                            ((void *)0)
# 226 ".././menu.c"
                                                ,{&midi_Couplers[0]},
# 226 ".././menu.c" 3 4
                                                                                  ((void *)0)
# 226 ".././menu.c"
                                                                                      ,menuOnExitCoupler},
 {9,0,"1<3",
# 227 ".././menu.c" 3 4
                         ((void *)0)
# 227 ".././menu.c"
                             ,{&midi_Couplers[1]},
# 227 ".././menu.c" 3 4
                                                               ((void *)0)
# 227 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"1<2",
# 228 ".././menu.c" 3 4
                         ((void *)0)
# 228 ".././menu.c"
                             ,{&midi_Couplers[2]},
# 228 ".././menu.c" 3 4
                                                               ((void *)0)
# 228 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"P<3",
# 229 ".././menu.c" 3 4
                         ((void *)0)
# 229 ".././menu.c"
                             ,{&midi_Couplers[3]},
# 229 ".././menu.c" 3 4
                                                               ((void *)0)
# 229 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"P<2",
# 230 ".././menu.c" 3 4
                         ((void *)0)
# 230 ".././menu.c"
                             ,{&midi_Couplers[4]},
# 230 ".././menu.c" 3 4
                                                               ((void *)0)
# 230 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"P<1",
# 231 ".././menu.c" 3 4
                         ((void *)0)
# 231 ".././menu.c"
                             ,{&midi_Couplers[5]},
# 231 ".././menu.c" 3 4
                                                               ((void *)0)
# 231 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"3<2",
# 232 ".././menu.c" 3 4
                         ((void *)0)
# 232 ".././menu.c"
                             ,{&midi_Couplers[6]},
# 232 ".././menu.c" 3 4
                                                               ((void *)0)
# 232 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"3<1",
# 233 ".././menu.c" 3 4
                         ((void *)0)
# 233 ".././menu.c"
                             ,{&midi_Couplers[7]},
# 233 ".././menu.c" 3 4
                                                               ((void *)0)
# 233 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"3<P",
# 234 ".././menu.c" 3 4
                         ((void *)0)
# 234 ".././menu.c"
                             ,{&midi_Couplers[8]},
# 234 ".././menu.c" 3 4
                                                               ((void *)0)
# 234 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"2<1",
# 235 ".././menu.c" 3 4
                         ((void *)0)
# 235 ".././menu.c"
                             ,{&midi_Couplers[9]},
# 235 ".././menu.c" 3 4
                                                               ((void *)0)
# 235 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9,0,"2<P",
# 236 ".././menu.c" 3 4
                         ((void *)0)
# 236 ".././menu.c"
                             ,{&midi_Couplers[10]},
# 236 ".././menu.c" 3 4
                                                               ((void *)0)
# 236 ".././menu.c"
                                                                   ,menuOnExitCoupler},
 {9| 0xC0,0,"1<P",
# 237 ".././menu.c" 3 4
                                            ((void *)0)
# 237 ".././menu.c"
                                                ,{&midi_Couplers[11]},
# 237 ".././menu.c" 3 4
                                                                                  ((void *)0)
# 237 ".././menu.c"
                                                                                      ,menuOnExitCoupler}
};


uint8_t menuOnExitSaveProgram(uint8_t arg);
uint8_t menuOnExitLoadProgran(uint8_t arg);
const __flash Menu_t menu_programm[] = {
 {12 | 0x80,0,"Laden",
# 244 ".././menu.c" 3 4
                                             ((void *)0)
# 244 ".././menu.c"
                                                 ,{&menuVKombination},
# 244 ".././menu.c" 3 4
                                                                      ((void *)0)
# 244 ".././menu.c"
                                                                          ,menuOnExitLoadProgran},
 {12 | 0xC0,0,"Speichern",
# 245 ".././menu.c" 3 4
                                                  ((void *)0)
# 245 ".././menu.c"
                                                      ,{&menuVKombination},
# 245 ".././menu.c" 3 4
                                                                           ((void *)0)
# 245 ".././menu.c"
                                                                               ,menuOnExitSaveProgram},
};


const __flash Menu_t menu_manual[] = {
 {(1 | 0x80),0,"Kombin.",menu_programm,{
# 250 ".././menu.c" 3 4
                                          ((void *)0)
# 250 ".././menu.c"
                                              },
# 250 ".././menu.c" 3 4
                                                ((void *)0)
# 250 ".././menu.c"
                                                    ,
# 250 ".././menu.c" 3 4
                                                     ((void *)0)
# 250 ".././menu.c"
                                                         },
 {1,0,"Koppler",menu_coupler,{
# 251 ".././menu.c" 3 4
                                       ((void *)0)
# 251 ".././menu.c"
                                           },
# 251 ".././menu.c" 3 4
                                             ((void *)0)
# 251 ".././menu.c"
                                                 ,
# 251 ".././menu.c" 3 4
                                                  ((void *)0)
# 251 ".././menu.c"
                                                      },
 {(1 | 0xC0),0,"Stimmen",menu_tune,{
# 252 ".././menu.c" 3 4
                                      ((void *)0)
# 252 ".././menu.c"
                                          },
# 252 ".././menu.c" 3 4
                                            ((void *)0)
# 252 ".././menu.c"
                                                ,
# 252 ".././menu.c" 3 4
                                                 ((void *)0)
# 252 ".././menu.c"
                                                     }
};


uint8_t menuOnExitKeys(uint8_t arg);
const __flash Menu_t menu_main[] = {
 {(1 | 0x80),0,"Manual",menu_manual,{
# 258 ".././menu.c" 3 4
                                       ((void *)0)
# 258 ".././menu.c"
                                           },
# 258 ".././menu.c" 3 4
                                             ((void *)0)
# 258 ".././menu.c"
                                                 ,
# 258 ".././menu.c" 3 4
                                                  ((void *)0)
# 258 ".././menu.c"
                                                      },
 {1,0,"MIDI",menu_midi,{
# 259 ".././menu.c" 3 4
                                 ((void *)0)
# 259 ".././menu.c"
                                     },
# 259 ".././menu.c" 3 4
                                       ((void *)0)
# 259 ".././menu.c"
                                           ,
# 259 ".././menu.c" 3 4
                                            ((void *)0)
# 259 ".././menu.c"
                                                },
 {1,0,"Tasten",menu_key,{
# 260 ".././menu.c" 3 4
                                  ((void *)0)
# 260 ".././menu.c"
                                      },
# 260 ".././menu.c" 3 4
                                        ((void *)0)
# 260 ".././menu.c"
                                            ,menuOnExitKeys},
 {1,0,"Status",menu_status,{
# 261 ".././menu.c" 3 4
                                     ((void *)0)
# 261 ".././menu.c"
                                         },
# 261 ".././menu.c" 3 4
                                           ((void *)0)
# 261 ".././menu.c"
                                               ,
# 261 ".././menu.c" 3 4
                                                ((void *)0)
# 261 ".././menu.c"
                                                    },
 {(1 | 0xC0),0,"Setup",menu_setup,{
# 262 ".././menu.c" 3 4
                                     ((void *)0)
# 262 ".././menu.c"
                                         },
# 262 ".././menu.c" 3 4
                                           ((void *)0)
# 262 ".././menu.c"
                                               ,
# 262 ".././menu.c" 3 4
                                                ((void *)0)
# 262 ".././menu.c"
                                                    }
};



uint8_t softKeyCoupler2from3(uint8_t arg);
uint8_t softKeyCoupler1from3(uint8_t arg);
uint8_t softKeyCouplerPfrom3(uint8_t arg);
uint8_t softKeyCoupler1from2(uint8_t arg);
uint8_t softKeyCouplerPfrom2(uint8_t arg);
uint8_t softKeyCouplerPfrom1(uint8_t arg);
uint8_t softKeyCoupler3from2(uint8_t arg);
uint8_t softKeyCoupler3from1(uint8_t arg);
uint8_t softKeyCoupler3fromP(uint8_t arg);
uint8_t softKeyCoupler2from1(uint8_t arg);
uint8_t softKeyCoupler2fromP(uint8_t arg);
uint8_t softKeyCoupler1fromP(uint8_t arg);
uint8_t softKeyK1A(uint8_t arg);
uint8_t softKeyK2A(uint8_t arg);
uint8_t softKeyK3A(uint8_t arg);
uint8_t softKeyK4A(uint8_t arg);

const __flash char shortKeyTextNone[10] = "";
const __flash char shortKeyTextMenu[10] = "Menu";
const __flash char shortKeyTextStim[10] = "Stim";
const __flash char shortKeyTextSetup[10] = "Setu";
const __flash char shortKeyTextMIDIoff[10] = "MOff";
const __flash char shortKeyTextCpl23[10] = "2<3\x80";
const __flash char shortKeyTextCpl13[10] = "1<3\x80";
const __flash char shortKeyTextCplP3[10] = "P<3\x80";
const __flash char shortKeyTextCpl12[10] = "1<2\x80";
const __flash char shortKeyTextCplP2[10] = "P<2\x80";
const __flash char shortKeyTextCplP1[10] = "P<1\x80";
const __flash char shortKeyTextCpl32[10] = "3<2\x80";
const __flash char shortKeyTextCpl31[10] = "3<1\x80";
const __flash char shortKeyTextCpl3P[10] = "3<P\x80";
const __flash char shortKeyTextCpl21[10] = "2<1\x80";
const __flash char shortKeyTextCpl2P[10] = "2<P\x80";
const __flash char shortKeyTextCpl1P[10] = "1<P\x80";
const __flash char shortKeyTextK1A[10] = "Kb1A";
const __flash char shortKeyTextK2A[10] = "Kb2A";
const __flash char shortKeyTextK3A[10] = "Kb3A";
const __flash char shortKeyTextK4A[10] = "Kb4A";

const __flash Menu_t menu_selFunc[] =
 {{(1 | 0x80),0x10,"<none>",
# 307 ".././menu.c" 3 4
                                                ((void *)0)
# 307 ".././menu.c"
                                                    ,{.pString=shortKeyTextNone},
# 307 ".././menu.c" 3 4
                                                                                 ((void *)0)
# 307 ".././menu.c"
                                                                                     ,
# 307 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 307 ".././menu.c"
                                                                                          },
 {1,0x10,"Menu",menu_main,{.pString=shortKeyTextMenu},
# 308 ".././menu.c" 3 4
                                                                                 ((void *)0)
# 308 ".././menu.c"
                                                                                     ,
# 308 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 308 ".././menu.c"
                                                                                          },
 {1,0x10,"Stimmen",menu_tune,{.pString=shortKeyTextStim},
# 309 ".././menu.c" 3 4
                                                                                    ((void *)0)
# 309 ".././menu.c"
                                                                                        ,
# 309 ".././menu.c" 3 4
                                                                                         ((void *)0)
# 309 ".././menu.c"
                                                                                             },
 {1,0x10,"Koppel2<3",
# 310 ".././menu.c" 3 4
                                                ((void *)0)
# 310 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl23},softKeyCoupler2from3,
# 310 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 310 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel1<3",
# 311 ".././menu.c" 3 4
                                                ((void *)0)
# 311 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl13},softKeyCoupler1from3,
# 311 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 311 ".././menu.c"
                                                                                                           },
 {1,0x10,"KoppelP<3",
# 312 ".././menu.c" 3 4
                                                ((void *)0)
# 312 ".././menu.c"
                                                    ,{.pString=shortKeyTextCplP3},softKeyCouplerPfrom3,
# 312 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 312 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel1<2",
# 313 ".././menu.c" 3 4
                                                ((void *)0)
# 313 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl12},softKeyCoupler1from2,
# 313 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 313 ".././menu.c"
                                                                                                           },
 {1,0x10,"KoppelP<2",
# 314 ".././menu.c" 3 4
                                                ((void *)0)
# 314 ".././menu.c"
                                                    ,{.pString=shortKeyTextCplP2},softKeyCouplerPfrom2,
# 314 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 314 ".././menu.c"
                                                                                                           },
 {1,0x10,"KoppelP<1",
# 315 ".././menu.c" 3 4
                                                ((void *)0)
# 315 ".././menu.c"
                                                    ,{.pString=shortKeyTextCplP1},softKeyCouplerPfrom1,
# 315 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 315 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel3<2",
# 316 ".././menu.c" 3 4
                                                ((void *)0)
# 316 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl32},softKeyCoupler3from2,
# 316 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 316 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel3<1",
# 317 ".././menu.c" 3 4
                                                ((void *)0)
# 317 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl31},softKeyCoupler3from1,
# 317 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 317 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel3<P",
# 318 ".././menu.c" 3 4
                                                ((void *)0)
# 318 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl3P},softKeyCoupler3fromP,
# 318 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 318 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel2<1",
# 319 ".././menu.c" 3 4
                                                ((void *)0)
# 319 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl21},softKeyCoupler2from1,
# 319 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 319 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel2<P",
# 320 ".././menu.c" 3 4
                                                ((void *)0)
# 320 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl2P},softKeyCoupler2fromP,
# 320 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 320 ".././menu.c"
                                                                                                           },
 {1,0x10,"Koppel1<P",
# 321 ".././menu.c" 3 4
                                                ((void *)0)
# 321 ".././menu.c"
                                                    ,{.pString=shortKeyTextCpl1P},softKeyCoupler1fromP,
# 321 ".././menu.c" 3 4
                                                                                                       ((void *)0)
# 321 ".././menu.c"
                                                                                                           },
 {1,0x10,"Kombin 1A",
# 322 ".././menu.c" 3 4
                                                ((void *)0)
# 322 ".././menu.c"
                                                    ,{.pString=shortKeyTextK1A},softKeyK1A,
# 322 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 322 ".././menu.c"
                                                                                               },
 {1,0x10,"Kombin 2A",
# 323 ".././menu.c" 3 4
                                                ((void *)0)
# 323 ".././menu.c"
                                                    ,{.pString=shortKeyTextK2A},softKeyK2A,
# 323 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 323 ".././menu.c"
                                                                                               },
 {1,0x10,"Kombin 3A",
# 324 ".././menu.c" 3 4
                                                ((void *)0)
# 324 ".././menu.c"
                                                    ,{.pString=shortKeyTextK3A},softKeyK3A,
# 324 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 324 ".././menu.c"
                                                                                               },
 {1,0x10,"Kombin 4A",
# 325 ".././menu.c" 3 4
                                                ((void *)0)
# 325 ".././menu.c"
                                                    ,{.pString=shortKeyTextK4A},softKeyK4A,
# 325 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 325 ".././menu.c"
                                                                                               },
 {1,0x10,"MIDI Off",
# 326 ".././menu.c" 3 4
                                               ((void *)0)
# 326 ".././menu.c"
                                                   ,{.pString=shortKeyTextMIDIoff},menu_OnEnterMidiPanic,
# 326 ".././menu.c" 3 4
                                                                                                         ((void *)0)
# 326 ".././menu.c"
                                                                                                             },
 {(1 | 0xC0),0x10,"Setup",menu_setup,{.pString=shortKeyTextSetup},
# 327 ".././menu.c" 3 4
                                                                                      ((void *)0)
# 327 ".././menu.c"
                                                                                          ,
# 327 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 327 ".././menu.c"
                                                                                               }};



const __flash NibbleInfo_t nibbleInfo[14] = {
 {0,{0,0,0,0,0,0,0,0}},
 {2,{0,1,0,0,0,0,0,0}},
 {1,{3,0,0,0,0,0,0,0}},
 {2,{0,2,0,0,0,0,0,0}},
 {3,{1,3,4,0,0,0,0,0}},
 {3,{0,1,2,0,0,0,0,0}},
 {1,{0,0,0,0,0,0,0,0}},
 {1,{0,0,0,0,0,0,0,0}},
 {1,{0,0,0,0,0,0,0,0}},
 {8,{0,1,2,3,4,5,6,7}},
 {8,{0,1,2,3,4,5,6,7}},
 {2,{0,1,0,0,0,0,0,0}},
 {2,{0,1,0,0,0,0,0,0}}
};

const __flash char initMenuText[10] = "Men\xf5";
const __flash char MenuMIDIInText[] = "In:";
const __flash char MenuMIDIOutText[] = "Out:";


const __flash Menu_t* currentMenu;
const __flash Menu_t* menuStack[16];
uint8_t menuStackIndex;

uint8_t nibbleIndex;
uint8_t nibbleCount;
uint8_t nibble[8];

uint16_t DataAdressOffset;
uint8_t dataEntry;
uint32_t dataEntry32;
uint8_t dataType;
uint8_t lcdData[10];
const __flash NibbleInfo_t* pNibbleInfo;

uint8_t menu_TestModulePattern;
uint8_t menu_TestModuleBitCounter;
uint32_t menu_TestModuleErrorList;

const __flash char* pMenuTopTitle;
uint8_t menuVmidiChan;
uint8_t menuVsection;
uint8_t menuVmanual;
uint8_t menuVkey;
uint8_t menuVmodule;
uint8_t menuVKombination;

const __flash Menu_t* menuVMenuSoftKey;
uint8_t menuVSoftKey;
uint32_t menuModVal;

uint8_t menuNote;
uint8_t menuMidiChan;
uint8_t menuSection;
uint8_t menuManual;
uint8_t menuTestModuleBit;
uint8_t menuTestData;

uint8_t soft_KeyMenuIndex[4];
SoftKeyMenu_List_t soft_KeyMenu[4];



uint8_t menuOnExitCoupler(uint8_t arg) {
 (void) arg;
 uint8_t cplNr = currentMenu->pVar - &midi_Couplers[0];
 if (midi_Couplers[cplNr] != 0){

  set_Coupler(cplNr);
 }
 return 0;
}

uint8_t softkeyCoupler(uint8_t arg, uint8_t CplNr){

 if (arg != 0){
  if (midi_Couplers[CplNr] == 0){
   uint8_t turnOffManual = set_Coupler(CplNr);
   if (turnOffManual != 0x00) {
    midi_ManualOff(turnOffManual);
   }
  } else {
   midi_Couplers[CplNr] = 0;
   midi_ManualOff(cplInfo[CplNr].dest);
  }
 }
 return (midi_Couplers[CplNr] == 0 ? 0x82 : 0x81);
}

uint8_t softKeyCoupler2from3(uint8_t arg){

 uint8_t result = softkeyCoupler(arg, 0);
 return result;
}

uint8_t softKeyCoupler1from3(uint8_t arg){
 uint8_t result = softkeyCoupler(arg, 1);
 return result;
}

uint8_t softKeyCouplerPfrom3(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,3);
 return result;
}

uint8_t softKeyCoupler1from2(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,2);
 return result;
}

uint8_t softKeyCouplerPfrom2(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,4);
 return result;
}

uint8_t softKeyCouplerPfrom1(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,5);
 return result;
}

uint8_t softKeyCoupler3from2(uint8_t arg){

 uint8_t result = softkeyCoupler(arg, 6);
 return result;
}

uint8_t softKeyCoupler3from1(uint8_t arg){
 uint8_t result = softkeyCoupler(arg, 7);
 return result;
}

uint8_t softKeyCoupler3fromP(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,9);
 return result;
}

uint8_t softKeyCoupler2from1(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,8);
 return result;
}

uint8_t softKeyCoupler2fromP(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,10);
 return result;
}

uint8_t softKeyCoupler1fromP(uint8_t arg){
 uint8_t result = softkeyCoupler(arg,11);
 return result;
}


uint8_t softKeyK1A(uint8_t arg){
 if ((arg & 0x80) != 0){

  register_toProgram(0);
 } else if (arg != 0) {
  program_toRegister(0);
 }
 return 0;
}

uint8_t softKeyK2A(uint8_t arg){
 if ((arg & 0x80) != 0){

  register_toProgram(1);
 } else if (arg != 0) {
  program_toRegister(1);
 }
 return 0;
}

uint8_t softKeyK3A(uint8_t arg){
 if ((arg & 0x80) != 0){

  register_toProgram(2);
 } else if (arg != 0) {
  program_toRegister(2);
 }
 return 0;
}

uint8_t softKeyK4A(uint8_t arg){
 if ((arg & 0x80) != 0){

  register_toProgram(3);
 } else if (arg != 0) {
  program_toRegister(3);
 }
 return 0;
}



uint8_t menuOnExitSaveProgram(uint8_t arg){
 if ((arg != 6) && (menuVKombination < 64)){
  register_toProgram(menuVKombination);
  eeprom_UpdateProg();
 }
 return 0;
}
uint8_t menuOnExitLoadProgran(uint8_t arg){
 if ((arg != 6) && (menuVKombination < 64)){
  program_toRegister(menuVKombination);
 }
 return 0;
}

uint8_t menuOnEnterPwrOn(uint8_t arg) {
 (void) arg;
 
# 542 ".././menu.c" 3
(*(volatile uint8_t *)((0x05) + 0x20)) 
# 542 ".././menu.c"
|= 1 << 6;
 pipe_PowerStatus = 0x13;
 menu_showPowerState();
 return 0;
}

uint8_t menuOnEnterPwrOff(uint8_t arg){
 (void) arg;
 
# 550 ".././menu.c" 3
(*(volatile uint8_t *)((0x05) + 0x20)) 
# 550 ".././menu.c"
&= ~(1 << 6);
 pipe_PowerStatus = 0x00;
 menu_showPowerState();
 return 0;
}

uint8_t menuOnEnterPwrRest(uint8_t arg){
 
# 557 ".././menu.c" 3
(*(volatile uint8_t *)((0x05) + 0x20)) 
# 557 ".././menu.c"
&= ~(1 << 6);
 (void) arg;
 pipe_PowerStatus = 0x01;
 menu_showPowerState();
 
# 561 ".././menu.c" 3
for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 561 ".././menu.c"
{swTimer[1].counter = 1000 / 20; swTimer[1].prescaler = (1000 % 20) / 4;};
 return 0;
}

uint8_t menuOnExitKeys(uint8_t arg){
 (void) arg;
 eeprom_UpdateSoftkeys();
 return 0;
}

const __flash char menuMessageMIDIpanic[] = "N.off sent";

uint8_t menu_OnEnterMidiPanic(uint8_t arg){
 (void) arg;
 lcd_goto((0+20 + 10));
 lcd_puts_P(menuMessageMIDIpanic);
 
# 577 ".././menu.c" 3
for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 577 ".././menu.c"
{swTimer[7].counter = 2000 / 20; swTimer[7].prescaler = (2000 % 20) / 4;};;
 midiSendAllNotesOff();
 menuCursorSetMenu();
 return 0;
}

uint8_t menu_ModuleTestPattern(uint8_t arg){
 (void) arg;
 menu_TestModulePattern = 1 << menuVmodule;
 menu_TestModuleBitCounter = 0xFF;
 menu_TestModuleErrorList = 0;
 menu_ModuleTestExecute();
 return 0;
}

void menu_ModuleTestExecute(){


 if ((menu_TestModuleBitCounter == 0xFF) || (menu_TestModuleBitCounter == 0xFD)){

  lcd_cursoroff();
  menu_ClearDataDisp();
  msgPipe_Handling = 0x00;
  Pipe_t* pPipe = &(pipe[0]);

  for (uint8_t i = 0; i < 32; i++){
   pPipe->pipeOut |= menu_TestModulePattern;
   pPipe++;
  }
  if (menu_TestModuleBitCounter == 0xFF){
   menu_TestModuleBitCounter = 0;
  } else {
   lcd_goto((0+20 + 10));
   lcd_putc('a');
   lcd_putc('b');
   lcd_putc('o');
   lcd_putc('r');
   lcd_putc('t');
   menu_TestModuleBitCounter = 0xFE;
   
# 616 ".././menu.c" 3
  for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 616 ".././menu.c"
  {swTimer[6].counter = 50 / 20; swTimer[6].prescaler = (50 % 20) / 4;};
   
# 617 ".././menu.c" 3
  for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 617 ".././menu.c"
  {swTimer[7].counter = 2000 / 20; swTimer[7].prescaler = (2000 % 20) / 4;};;
   menuCursorSetMenu();
  }
 } else if (menu_TestModuleBitCounter == 0xFE) {
  msgPipe_Handling = 0xFF;
  menu_TestModulePattern = 0;

  lcd_cursosblink();
 } else {


  menu_TestModuleErrorList >>= 1;
  if ((pipe[menu_TestModuleBitCounter].pipeIn & menu_TestModulePattern) == 0){

   menu_TestModuleErrorList |= 0x80000000;
  }

  pipe[menu_TestModuleBitCounter].pipeOut |= menu_TestModulePattern;
  menu_TestModuleBitCounter++;
 }

 if (menu_TestModuleBitCounter < 32){

  pipe[menu_TestModuleBitCounter].pipeOut &= ~menu_TestModulePattern;
  lcd_goto((0+20 + 10));
  lcd_dec2out(menu_TestModuleBitCounter);

  
# 644 ".././menu.c" 3
 for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 644 ".././menu.c"
 {swTimer[6].counter = 160 / 20; swTimer[6].prescaler = (160 % 20) / 4;};
 } else if (menu_TestModuleBitCounter == 32) {

  lcd_goto((0+20 + 10));
  if (menu_TestModuleErrorList == 0){
   lcd_putc('o');
   lcd_putc('k');
  } else {
   editLong.longval = menu_TestModuleErrorList;
   lcd_putc('E');
   lcd_putc(':');
   lcd_longout();
  }
  menu_TestModuleBitCounter = 0xFE;
  
# 658 ".././menu.c" 3
 for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 658 ".././menu.c"
 {swTimer[6].counter = 50 / 20; swTimer[6].prescaler = (50 % 20) / 4;};
  
# 659 ".././menu.c" 3
 for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 659 ".././menu.c"
 {swTimer[7].counter = 2000 / 20; swTimer[7].prescaler = (2000 % 20) / 4;};;
  menuCursorSetMenu();
 }

}

uint8_t menu_enterWriteModule(uint8_t arg){
 (void) arg;
 menuModVal = 0;
 uint8_t moduleMask = 1 << menuVmodule;
 Pipe_t* pPipe = &(pipe[32 -1]);
 for (uint8_t i = 0; i < 32; i++){
  menuModVal <<= 1;
  if ((pPipe->pipeOut & moduleMask) != 0){
   menuModVal |= 1;
  }
  pPipe--;
 }
 return 0;
}

uint8_t menu_exitWriteModule(uint8_t arg){
 uint32_t writeVal = menuModVal;
 if (arg == 5){
  uint8_t moduleMask = 1 << menuVmodule;
  Pipe_t* pPipe = &(pipe[32 -1]);
  for (uint8_t i = 0; i < 32; i++){
   if ((writeVal & 0x80000000) != 0){
    pPipe->pipeOut |= moduleMask;
   } else {
    pPipe->pipeOut &= ~moduleMask;
   }
   writeVal <<= 1;
   pPipe--;
  }
 }
 return 0;
}

uint8_t menu_readModule(uint8_t arg){
 (void) arg;
 uint32_t readVal = 0;
 uint8_t moduleMask = 1 << menuVmodule;
 Pipe_t* pPipe = &(pipe[32 -1]);
 for (uint8_t i = 0; i < 32; i++){
  readVal <<= 1;
  if ((pPipe->pipeIn & moduleMask) != 0){
   readVal |= 1;
  }
  pPipe--;
 }
 lcd_goto((0+20 + 10));
 editLong.longval = readVal;
 lcd_longout();
 return 0;
}

uint8_t menu_testModule(uint8_t arg){
 (void) arg;
 lcd_goto((0+20 + 10));
 editLong.longval = test_PipeModule(menuVmodule);
 lcd_longout();
 return 0;
}

uint8_t menuOnEnterModSel(uint8_t arg){
 (void) arg;
 menuVmodule = currentMenu->tag;
 return 0;
};

uint8_t menuOnEnterMidiInCh(uint8_t arg){
 (void) arg;
 menuVmidiChan = currentMenu->tag;
 return 0;
}

uint8_t menuOnEnterMidiInSec(uint8_t arg){
 (void) arg;
 menuVsection = currentMenu->tag;
 DataAdressOffset = (&(midiInMap[menuVmidiChan & 0x0F][menuVsection & 0x03]) - &(midiInMap[0][0])) * sizeof(MidiInMap_t);
 return 0;
}

uint8_t menuOnEnterModManual(uint8_t arg){
 (void) arg;
 menuVmanual = currentMenu->tag;
 return 0;
}

uint8_t menuOnEnterModSec(uint8_t arg){
 (void) arg;
 menuVsection = currentMenu->tag;
 DataAdressOffset = (&(manualMap[menuVmanual & 0x0F][menuVsection & 0x03]) - &(manualMap[0][0])) * sizeof(ManualMap_t);
 return 0;
}

uint8_t menuOnEnterModSecReg(uint8_t arg){
 (void) arg;
 menuVsection = currentMenu->tag;
 DataAdressOffset = (&(registerMap[menuVsection & 0x07]) - &(registerMap[0])) * sizeof(RegisterMap_t);
 return 0;
}


uint8_t menuOnEnterKey(uint8_t arg){
 (void) arg;
 uint8_t softKeyNr;
 softKeyNr = currentMenu->tag;
 if (softKeyNr < 4){
  menuVMenuSoftKey = soft_KeyMenu[softKeyNr].pSelMenu;
 }
 return 0;
}

uint8_t menuOnExitKey(uint8_t arg){
 (void) arg;
 uint8_t softKeyNr;
 softKeyNr = currentMenu->tag;
 softKey_Set(menuVMenuSoftKey,softKeyNr);
 return 0;
}

const char stringNotAssigen [] 
# 782 ".././menu.c" 3
                              __attribute__((__progmem__)) 
# 782 ".././menu.c"
                                      = "unassigned";
uint8_t menuOnEnterTune(uint8_t arg){
 (void) arg;
 static uint8_t minManNote;
 static uint8_t maxManNote;
 static uint8_t notOnOff;
 uint8_t result = 0xFF;

 if (arg == 0xFF){

  minManNote = 0xFF;
  maxManNote = 0;
  menuVmanual = currentMenu->tag;
  if (menuVmanual > 3) {
   menuVmanual = 0;
  }
  for (uint8_t i = 0; i < 4; i++){
   if (manualMap[menuVmanual][i].startNote < minManNote){
    minManNote = manualMap[menuVmanual][i].startNote;
   }
   if (manualMap[menuVmanual][i].endNote > maxManNote){
    maxManNote = manualMap[menuVmanual][i].endNote;
   }
  }
  if (minManNote > 0x7F){

   lcd_goto((0+20 + 10));
   lcd_puts_P(stringNotAssigen);
   menuNote = 0xFF;
  } else {
   menuNote = minManNote;
   notOnOff = 0x00;
  }
  keylabel_set(0,keylabel_exit);
  keylabel_set(1,keylabel_onoff);
  keylabel_set(2,keylabel_minus);
  keylabel_set(3,keylabel_plus);
  keylabel_toLCD();
 } else if (menuNote == 0xFF) {
  result = 0x00;
 } else if (arg == 1) {
  if (menuNote < maxManNote){
   manual_NoteOnOff(menuVmanual,menuNote,0x00);
   menuNote++;
   if (notOnOff == 0x01){
    manual_NoteOnOff(menuVmanual,menuNote,0x01);
   }
  }
 } else if (arg == 4) {
  if (menuNote > minManNote){
   manual_NoteOnOff(menuVmanual,menuNote,0x00);
   menuNote--;
   if (notOnOff == 0x01){
    manual_NoteOnOff(menuVmanual,menuNote,0x01);
   }
  }
 } else if (arg == 3) {
  if (notOnOff == 0x00){
   notOnOff = 0x01;
  } else {
   notOnOff = 0x00;
  }
  manual_NoteOnOff(menuVmanual,menuNote,notOnOff);
 } else if ((arg == 2) || (arg == 6)) {
  manual_NoteOnOff(menuVmanual,menuNote,0x00);
  result = 0x00;
 } else if (arg == 5) {
  manual_NoteOnOff(menuVmanual,menuNote,0x00);
  result = 0x00;
 }
 if (result == 0xFF){

  if (menuNote != 0xFF) {

   lcd_goto((0+20 + 10));
   lcd_noteOut(menuNote);
   lcd_putc(' ');
   if (notOnOff == 0x00){
    lcd_putc('a');
    lcd_putc('u');
    lcd_putc('s');
    } else {
    lcd_putc('e');
    lcd_putc('i');
    lcd_putc('n');
   }
   if (keylabel_statcheck(1,(notOnOff != 0x00)) != 0) {
    keylabel_toLCD();
   }
  }
  lcd_goto((0+20 + 10));
 }
 return result;
}

uint8_t menuOnExitMidiActiveSense(uint8_t arg){
 (void) arg;
 eeprom_UpdateMidiOutMap();
 return 0;
}

uint8_t menuOnEnterStatusMidiIn(uint8_t arg){
 (void) arg;
 uint8_t byteCount;
 uint8_t *pByte;
 menuCursorSetExtra();
 lcd_puts_P(MenuMIDIInText);
 lcd_wordout(midiRxBytesCount);
 lcd_putc('-');

 if (midiRxBytesCount < 4) {
  byteCount = midiRxBytesCount;
 } else {
  byteCount = 4;
 }
 pByte = & (midiRxBuffer[midiRxInIndex]);
 pByte--;
 while (byteCount > 0){
  if (pByte < &(midiRxBuffer[0])){
   pByte = &(midiRxBuffer[32 -1]);
  }
  lcd_hexout(*pByte--);
  if (--byteCount != 0) {
   lcd_putc(' ');
  }
 }
 return 0;
}
uint8_t menuOnEnterStatusMidiOut(uint8_t arg){
 (void) arg;
 uint8_t byteCount;
 uint8_t *pByte;
 menuCursorSetExtra();
 lcd_puts_P(MenuMIDIOutText);
 lcd_wordout(midiTxBytesCount);
 lcd_putc('-');

 if (midiTxBytesCount < 4) {
  byteCount = midiTxBytesCount;
  } else {
  byteCount = 4;
 }
 pByte = & (midiTxBuffer[midiTxInIndex]);
 pByte--;
 while (byteCount > 0){
  if (pByte < &(midiTxBuffer[0])){
   pByte = &(midiTxBuffer[32 -1]);
  }
  lcd_hexout(*pByte--);
  if (--byteCount != 0) {
   lcd_putc(' ');
  }
 }
 return 0;
}

uint8_t menuOnExitMidiIn(uint8_t arg){
 (void) arg;
 eeprom_UpdateMidiInMap();
 return 0;
}

uint8_t menuOnExitMidiOut(uint8_t arg){
 (void) arg;
 eeprom_UpdateMidiOutMap();
 return 0;
}

uint8_t menuOnExitManual(uint8_t arg){
 (void) arg;
 eeprom_UpdateManualMap();
 registers_CalcCount();
 eeprom_UpdateReg();
 Midi_updateManualRange();
 return 0;
}

uint8_t menuOnExitModules(uint8_t arg){
 (void) arg;
 eeprom_UpdateModules();
 return 0;
}

const char logNone [] 
# 965 ".././menu.c" 3
                     __attribute__((__progmem__)) 
# 965 ".././menu.c"
                             = "<none>";

uint8_t menuOnEnterLogDisp(uint8_t arg) {
 (void) arg;
 static uint8_t logEntryNr;
 static uint8_t showText;
 uint8_t continueLogMenu = 0xFF;

 if (arg == 0xFF){
  logEntryNr = log_count()-1;
  showText = 0x00;
  keylabel_set(0,keylabel_exit);
  keylabel_set(1,keylabel_text);
  keylabel_toLCD();
 } else if (arg == 4) {
  if (logEntryNr != 0) {
   logEntryNr--;
  }
 } else if (arg == 1) {
  if (logEntryNr+1 < log_count()) {
   logEntryNr++;
  }
 } else if ((arg == 3) || (arg == 5)) {
  showText = ~showText;
 } else {
  continueLogMenu = 0x00;
 }
 if (continueLogMenu == 0xFF){

  lcd_goto(0+20);
  if (log_count() == 0){
   lcd_puts_P(logNone);
   continueLogMenu = 0x00;
  } else {
   lcd_dec2out(logEntryNr+1);
   lcd_putc(':');
   if (showText == 0x00){
    lcd_puts(log_getShortTextFromIndex(logEntryNr,' '));
   } else {
    lcd_puts_P(getErrorText(logEntryNr));
   }
   lcd_clrEol();
   menuCursorSetExtra();
  }
  keylabel_statcheck(1,(showText == 0xFF));
  if (logEntryNr+1 < log_count()){
   keylabel_set(3,keylabel_right);
  } else {
   keylabel_clr(3);
  }
  if (logEntryNr > 0){
   keylabel_set(2,keylabel_left);
  } else {
   keylabel_clr(2);
  }
  keylabel_toLCD();
 }
 return continueLogMenu;
}


const char msg_programming1[] 
# 1026 ".././menu.c" 3
                             __attribute__((__progmem__)) 
# 1026 ".././menu.c"
                                     = "save...";
const char msg_programming2[] 
# 1027 ".././menu.c" 3
                             __attribute__((__progmem__)) 
# 1027 ".././menu.c"
                                     = "ok     ";

void menuLCDwriteOK(){
 lcd_goto((0+20 + 10));
 lcd_puts_P(msg_programming2);
 
# 1032 ".././menu.c" 3
for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)((0x3F) + 0x20)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 1032 ".././menu.c"
{swTimer[7].counter = 2000 / 20; swTimer[7].prescaler = (2000 % 20) / 4;};;
}

uint8_t menuOnEnterEEBackup(uint8_t arg){
 (void) arg;
 lcd_goto((0+20 + 10));
 lcd_puts_P(msg_programming1);
 eeprom_Backup();
 menuLCDwriteOK();
 return 0;
}

uint8_t menuOnEnterEERestore(uint8_t arg){
 (void) arg;
 lcd_goto((0+20 + 10));
 lcd_puts_P(msg_programming1);
 eeprom_Restore();
 menuLCDwriteOK();
 return 0;
}

uint8_t menuOnEnterEEUpdate(uint8_t arg){
 (void) arg;
 lcd_goto((0+20 + 10));
 lcd_puts_P(msg_programming1);
 eeprom_UpdateALL();
 menuLCDwriteOK();
 return 0;
}

const char usbEmpty [] 
# 1062 ".././menu.c" 3
                      __attribute__((__progmem__)) 
# 1062 ".././menu.c"
                              = "empty\r\n";
const char usbLog [] 
# 1063 ".././menu.c" 3
                    __attribute__((__progmem__)) 
# 1063 ".././menu.c"
                            = "Log\r\n";

uint8_t menuOnEnterUSBprotokoll(uint8_t arg){
 (void) arg;
 serial0SER_USB_sendStringP(usbLog);
 uint8_t count = log_count();
 if (count == 0) {
   serial0SER_USB_sendStringP(usbEmpty);
 } else {
  while (count-- > 0){
   serial0SER_USB_sendString(log_getShortTextFromIndex(count,0xFF));
   serial0SER_USB_sendStringP(cr_lf);
  }
 }
 return 0;
}

const char HelloMsg [] 
# 1080 ".././menu.c" 3
                      __attribute__((__progmem__)) 
# 1080 ".././menu.c"
                              = "\r\nMIDI-Organ-Interface\r\n";

uint8_t menuOnExitUSBactive(uint8_t arg){
 (void) arg;
 eeprom_UpdateUSB();
 if (serusb_Active == 0xFF){
  serial0SER_USB_sendStringP(HelloMsg);
  serial0SER_USB_sendStringP(sw_version);
  serial0SER_USB_sendStringP(cr_lf);
 }
 return 0;
}

const char usbHWtitel [] 
# 1093 ".././menu.c" 3
                        __attribute__((__progmem__)) 
# 1093 ".././menu.c"
                                = "Hardware Configuration\r\n";
const char usbHWmodulInst [] 
# 1094 ".././menu.c" 3
                            __attribute__((__progmem__)) 
# 1094 ".././menu.c"
                                    = "Modules assigned: ";
const char usbHWmodulCheck [] 
# 1095 ".././menu.c" 3
                             __attribute__((__progmem__)) 
# 1095 ".././menu.c"
                                     = "Modules checked: ";
const char usbHWManual [] 
# 1096 ".././menu.c" 3
                         __attribute__((__progmem__)) 
# 1096 ".././menu.c"
                                 = "Manual: ";
const char usbHWRange [] 
# 1097 ".././menu.c" 3
                        __attribute__((__progmem__)) 
# 1097 ".././menu.c"
                                = "Range: ";
const char usbHWempty [] 
# 1098 ".././menu.c" 3
                        __attribute__((__progmem__)) 
# 1098 ".././menu.c"
                                = "empty";
const char usbHWmodule [] 
# 1099 ".././menu.c" 3
                         __attribute__((__progmem__)) 
# 1099 ".././menu.c"
                                 = "Module:";
const char usbHWBits [] 
# 1100 ".././menu.c" 3
                       __attribute__((__progmem__)) 
# 1100 ".././menu.c"
                               = ",Bits:";

uint8_t menuOnEnterUSBsendHW(uint8_t arg){
 (void) arg;
 char* buffer;
 serial0SER_USB_sendStringP(usbHWtitel);
 serial0SER_USB_sendStringP(usbHWmodulInst);
 buffer = putChar_hex(pipe_ModuleAssnRead,string_Buf);
 *buffer++ = 'r';
 *buffer++ = ' ';
 buffer = putChar_hex(pipe_ModuleAssnWrite,buffer);
 *buffer++ = 'w';
 serial0SER_USB_sendString(string_Buf);
 serial0SER_USB_sendCRLF();
 serial0SER_USB_sendStringP(usbHWmodulCheck);
 putChar_hex(pipe_ModuleTested,string_Buf);
 serial0SER_USB_sendString(string_Buf);
 serial0SER_USB_sendCRLF();
 for (uint8_t manual = 0; manual < 4; manual++){

  serial0SER_USB_sendStringP(usbHWManual);
  putChar_Manual(manual, string_Buf);
  serial0SER_USB_sendString(string_Buf);
  serial0SER_USB_sendCRLF();
  for (uint8_t range = 0; range < 4; range++){

   serial0SER_USB_sendStringP(usbHWRange);
   serial0SER_USBSend('0'+range);
   serial0SER_USBSend('-');
   serial0SER_USBSend(' ');
   buffer = putChar_hex(manualMap[manual][range].startNote, string_Buf);
   *buffer++ = ' ';
   buffer = putChar_hex(manualMap[manual][range].endNote, buffer);
   *buffer++ = ' ';
   buffer = putChar_hex(manualMap[manual][range].bitStart, buffer);
   *buffer++ = '=';
   serial0SER_USB_sendString(string_Buf);
   if (manualMap[manual][range].startNote > 0x7F){
    serial0SER_USB_sendStringP(usbHWempty);
   } else {
    buffer = putChar_Note(manualMap[manual][range].startNote, string_Buf);
    *buffer++ = '-';
    buffer = putChar_Note(manualMap[manual][range].endNote, buffer);
    *buffer++ = ' ';
    serial0SER_USB_sendString(string_Buf);
    serial0SER_USB_sendStringP(usbHWmodule);
    serial0SER_USBSend('0'+(manualMap[manual][range].bitStart >> 5));
    serial0SER_USB_sendStringP(usbHWBits);
    buffer = putChar_Dec2(manualMap[manual][range].bitStart & 0x1F,string_Buf);
    *buffer++ = '-';
    buffer = putChar_Dec2((manualMap[manual][range].bitStart & 0x1F) + manualMap[manual][range].endNote - manualMap[manual][range].startNote,buffer);
    serial0SER_USB_sendString(string_Buf);
   }
   serial0SER_USB_sendCRLF();
  }
 }
 return 0;
}




void menu_Init(const __flash Menu_t* newMenu, const __flash char* pTitle){
 menuStackIndex = 0;
 if (newMenu == 
# 1164 ".././menu.c" 3 4
               ((void *)0)
# 1164 ".././menu.c"
                   ){
  currentMenu = menu_main;
  pMenuTopTitle = initMenuText;
 } else {
  currentMenu = newMenu;
  pMenuTopTitle = pTitle;
 }
 nibbleIndex = 0xFF;
 pNibbleInfo = &(nibbleInfo[0]);
}

void menu_InitLCD(){
 menuClearExtraDisp();
 menuItemChanged();
 menuParentMenuToLCD();
 menuCurrMenuToLCD();
 lcd_cursosblink();
}





void softkeyLeft(){
 keylabel_set(2,keylabel_left);
}

void softkeyRight(){
 keylabel_set(3,keylabel_right);
}

void softkeyDown(){
 keylabel_set(1,keylabel_down);
}

void softkeyUp(){
 keylabel_set(0,keylabel_up);
}

void softkeyPlus(){
 if (dataType == 10) {
  keylabel_set(0,keylabel_1);
 } else {
  keylabel_set(0,keylabel_plus);
 }
}

void softkeyMinus(){
 if (dataType == 10) {
  keylabel_set(1,keylabel_0);
 } else {
  keylabel_set(1,keylabel_minus);
 }
}



void dataToNibbles(){

 switch(dataType){
 case 2:
  nibble[0] = dataEntry >> 4;
  nibble[1] = dataEntry & 0x0F;

  break;
 case 3:

  if (dataEntry >= 16) {
   nibble[0] = 0xFF;
  } else {
   nibble[0] = dataEntry + 1;
  }
  break;
 case 4:

  if ((dataEntry & 0x80) != 0) {
   nibble[0] = 0x0;
   nibble[1] = 0xFF;
  } else {
   nibble[1] = 0;
   while (dataEntry >= 12){
    nibble[1]++;
    dataEntry -= 12;
   }
   nibble[0] = dataEntry;
  }
  break;
 case 5:

  nibble[0] = dataEntry >> 5;
  dataEntry &= 0x1F;
  nibble[1] = 0;
  while (dataEntry >= 10){
   nibble[1]++;
   dataEntry -= 10;
  }
  nibble[2] = dataEntry;
  break;
 case 6:

  nibble[0] = 0;
  nibble[1] = 0;
  while (dataEntry >= 100){
   nibble[0]++;
   dataEntry -= 100;
  }
  while (dataEntry >= 10){
   nibble[1]++;
   dataEntry -= 10;
  }
  nibble[2] = dataEntry;
  break;
 case 7:

  if (dataEntry > 3){
   nibble[0] = 0xFF;
  } else {
   nibble[0] = dataEntry;
  }
  break;
 case 8:

  if (dataEntry > 3){
   nibble[0] = 3;
  } else {
   nibble[0] = dataEntry;
  }
  break;
 case 9:

  nibble[0] = dataEntry;
  break;
 case 10:
  for (uint8_t i = 0; i<8; i++){
   nibble[i] = (dataEntry & 0x80) != 0 ? 1 : 0;
   dataEntry = dataEntry << 1;
  }
  break;
 case 11:
  ;
  uint8_t i = 8;
  uint8_t * pWordByte = (uint8_t *) & (dataEntry32);
  while (i-- != 0){
   nibble[i--] = *pWordByte & 0x0F;
   nibble[i] = *pWordByte++ >> 4;
  }
  break;
 case 12:
  nibble[0] = (dataEntry & 7) + 1;
  nibble[1] = (dataEntry >> 3) + 1;
  break;
 case 13:

  dataEntry++;
  nibble[0] = 0;
  while (dataEntry >= 10){
   nibble[0]++;
   dataEntry -= 10;
  }
  nibble[1] = dataEntry;
  break;
 }
}

void nibbleToLCDstring(){
 switch(dataType){
 case 2:
  lcdData[0] = nibbleToChr(nibble[0]);
  lcdData[1] = nibbleToChr(nibble[1]);
  lcdData[2] = 0;
  break;
 case 3:
  lcdData[0] = 'C';
  lcdData[1] = 'h';
  if (nibble[0] == 0xFF) {
   lcdData[2] = ' ';
   lcdData[3] = '-';
  } else {
   if (nibble[0] > 9) {
    lcdData[2] = '1';
    lcdData[3] = nibbleToChr(nibble[0]-10);
   } else {
    lcdData[2] = '0';
    lcdData[3] = nibbleToChr(nibble[0]);
   }
  }
  lcdData[4] = 0;
  break;
 case 4:
  if ((nibble[0] == 0xFF) || (nibble[1] == 0xFF)) {
   lcdData[0] = 'n';
   lcdData[1] = 'o';
   lcdData[2] = 'n';
   lcdData[3] = 'e';
   lcdData[4] = 0;
  } else {
   lcdData[1] = '_';
   if (nibble[0] == 11){
    lcdData[0] = 'H';
   } else if (nibble[0] < 5) {

    lcdData[0] = 'C' + (nibble[0] >> 1);
    if ((nibble[0] & 0x01) == 0x01) {
     lcdData[1] = '#';
    }
   } else {

    lcdData[0] = 'F' + ((nibble[0]-5) >> 1);
    if ((nibble[0] & 0x01) == 0x00) {
     lcdData[1] = '#';
    }
    if (lcdData[0] == 'H'){
     lcdData[0] = 'A';
    }
   }
   if (nibble[1] == 0){
    lcdData[2] = 'm';
   } else if (nibble[1] < 12) {
    lcdData[2] = nibbleToChr(nibble[1]-1);
   } else {
    lcdData[2] = '-';
   }
   lcdData[3] = 0;
  }
  break;
 case 5:
  lcdData[0] = 'M';
  lcdData[1] = nibbleToChr(nibble[0]);
  lcdData[2] = 'B';
  lcdData[3] = nibbleToChr(nibble[1]);
  lcdData[4] = nibbleToChr(nibble[2]);
  lcdData[5] = 0;
  break;
 case 6:
  lcdData[0] = nibbleToChr(nibble[0]);
  lcdData[1] = nibbleToChr(nibble[1]);
  lcdData[2] = nibbleToChr(nibble[2]);
  lcdData[3] = 0;
  break;
 case 7:
# 1428 ".././menu.c"
   if (nibble[0] <= 2){
    lcdData[0] = '3'-nibble[0];
    lcdData[1] = '\0';
   } else if (nibble[0] == 3){
    lcdData[0] = 'P';
    lcdData[1] = '\0';
   } else {

    lcdData[0] = '-';
    lcdData[1] = '\0';
   }

  break;
 case 8:
  lcdData[0] = nibble[0] + '0';
  lcdData[1] = '\0';
  break;
 case 9:
  if (nibble[0] == 0x00) {
   lcdData[0] = 'a';
   lcdData[1] = 'u';
   lcdData[2] = 's';
  } else {
   lcdData[0] = 'e';
   lcdData[1] = 'i';
   lcdData[2] = 'n';
  }
  lcdData[3] = '\0';
  break;
 case 10:
 case 11:
  for (uint8_t i=0; i<8; i++){
   lcdData[i] = nibbleToChr(nibble[i]);
  }
  break;
 case 12:
  lcdData[0] = '0' +nibble[0];
  lcdData[1] = '@' +nibble[1];
  lcdData[2] = '\0';
  break;
 case 13:
  if ((nibble[0] | nibble[1]) == 0) {

   lcdData[0] = '-';
   lcdData[1] = '-';
  } else {
   lcdData[0] = '0' +nibble[0];
   lcdData[1] = '0' +nibble[1];
  }
  lcdData[2] = '\0';
  break;
 }
}

void LCDStringOut(){
 lcd_goto((0+20 + 10));
 uint8_t* pData = lcdData;
 uint8_t outdata;
 for (uint8_t i = 0; i < 10; i++){
  if ((outdata = *pData) == '\0'){
   outdata = ' ';
  } else {
   pData++;
  }
  lcd_putc(outdata);
 }
}

uint8_t nibbleCheckOvfl(int8_t myNibble){

 if (myNibble > 9) {
  return (0);
 } else if (myNibble < 0) {
  return (9);
 }
 return myNibble;
}

void nibbleChange(uint8_t nibbleNr , int8_t addValue){


 uint8_t allowInvalid = (currentMenu->menuFlags & 0x10);
 switch(dataType){
  case 2:
  case 11:
   nibble[nibbleNr] = (nibble[nibbleNr] + addValue) & 0x0F;
   break;
  case 3:
   if (allowInvalid == 0) {

    if ((addValue == 1) && (nibble[0] == 16)){
     nibble[0] = 1;
    } else if ((addValue == -1) && (nibble[0] == 1)){
     nibble[0] = 16;
    } else {
     nibble[0] = nibble[0] + addValue;
    }
   } else {

    if ((addValue == 1) && (nibble[0] == 16)){
     nibble[0] = 0xFF;
    } else if ((addValue == 1) && (nibble[0] == 0xFF)){
     nibble[0] = 1;
    } else if ((addValue == -1) && (nibble[0] == 0xFF)){
     nibble[0] = 16;
    } else if ((addValue == -1) && (nibble[0] == 1)){
     nibble[0] = 0xFF;
    } else {
     nibble[0] = nibble[0] + addValue;
    }
   }
   break;
  case 4:
   if (nibble[1] == 0xFF) {

    nibbleNr = 1;
   }
   if (nibbleNr == 0){

    uint8_t newNote = nibble[0];
    if (newNote >= 12){

     newNote = 0;
    } else if ((newNote == 11) && (addValue == 1)) {
     newNote = 0;
    } else if ((newNote == 0) && (addValue == -1)) {
     newNote = 11;
    } else {
     newNote = newNote+addValue;
    }
    nibble[0] = newNote;
   } else {

    uint8_t octave = nibble[1];
    if (allowInvalid == 0){
     if ((octave == 0) && (addValue == -1)){
      octave = 10;
     } else if ((octave == 10) && (addValue == 1)){
      octave = 0;
     } else {
      octave = octave + addValue;
     }
    } else {
     if ((octave == 0) && (addValue == -1)){
      octave = 0xFF;
     } else if ((octave == 10) && (addValue == 1)){
      octave = 0xFF;
     } else if ((octave == 0xFF) && (addValue == 1)){
      octave = 0;
     } else if ((octave == 0xFF) && (addValue == -1)){
      octave = 10;
     } else {
      octave = octave + addValue;
     }
    }
    nibble[1] = octave;
   }
   if ((nibble[0] != 0xFF) && (nibble[1] != 0xFF)) {
    uint8_t newOctNote;
    newOctNote = nibble[0] + 12 * nibble[1];
    if (newOctNote > 127){
     nibble[0] = 7;
     nibble[1] = 10;
    }
   }
   break;
  case 5:
   if (nibbleNr == 0) {

    nibble[0] = (nibble[0] + addValue) & 0x07;
   } else {
    nibble[nibbleNr] = nibbleCheckOvfl(nibble[nibbleNr] + addValue);
    int8_t bitNr = 10 * nibble[1] + nibble[2];
    if (bitNr > 31){
     nibble[1] = 3;
     nibble[2] = 1;
    } else if (bitNr < 0){
     nibble[1] = 0;
     nibble[2] = 0;
    }
   }
   break;
  case 6:
   nibble[nibbleNr] = nibbleCheckOvfl(nibble[nibbleNr] + addValue);
   int16_t newDec = 100 * nibble[0] + 10 * nibble[1] + nibble[2];
   if (newDec > 255){
    nibble[0] = 2;
    nibble[1] = 5;
    nibble[2] = 5;
   }
   break;
  case 7:
   if (allowInvalid) {
    nibble[nibbleNr] = nibble[nibbleNr] + addValue;

    if (nibble[nibbleNr] == 3 +1) {

     nibble[nibbleNr] = 0xFF;
    } else if (nibble[nibbleNr] == 0xFF -1) {
     nibble[nibbleNr] = 3;
    }
   } else {
    if ((nibble[nibbleNr] == 0) && (addValue == -1)){
     nibble[nibbleNr] = 3;
    } else if ((nibble[nibbleNr] == 3) && (addValue == 1)){
     nibble[nibbleNr] = 0;
    } else {
     nibble[nibbleNr] = nibble[nibbleNr] + addValue;
    }
   }
   break;
  case 8:
   nibble[nibbleNr] = (nibble[nibbleNr] + addValue) & 0x03;
   break;
  case 9:
   nibble[0] = ~nibble[0];
   break;
  case 10:
   nibble[nibbleNr] = ((addValue >> 1) & 0x01) ^ 0x01;
   break;
  case 12:
   if (addValue == 1) {
    nibble[nibbleNr] = (nibble[nibbleNr] & 0x07) + 1;
   } else {
    nibble[nibbleNr] = ((nibble[nibbleNr]-2) & 0x07) +1;
   }
   break;
  case 13:
   ;
   int8_t myVal = nibble[0] * 10 + nibble[1];
   if (nibbleNr == 0) {

    myVal += addValue * 10;
   } else {

    myVal += addValue;
   }
   if (myVal < 0) {
    myVal = 0;
   } else if (myVal > 64) {
    myVal = 0;
   }
   nibble[0] = 0;
   while (myVal >= 10){
    nibble[0]++;
    myVal -= 10;
   }
   nibble[1] = myVal;
   break;

 }
}

void nibbleToData(){

 uint8_t tempb ;
 uint16_t temp;
 switch(dataType){
 case 2:
  dataEntry = (nibble[0] << 4) | (nibble[1] & 0x0F);
  break;
 case 3:
  if (nibble[0] == 0xFF) {
   dataEntry = nibble[0];
  } else {
   dataEntry = nibble[0]-1;
  }
  break;
 case 4:
  if ((nibble[0] == 0xFF) || (nibble[1] == 0xFF)) {
   dataEntry = 0xFF;
  } else {
   dataEntry = 12 * nibble[1] + nibble[0];
  }
  break;
 case 5:
  dataEntry = (nibble[0] << 5) & 0xE0;
  tempb = nibble[1] * 10 + nibble[2];
  if (tempb > 0x1F){
   dataEntry |= 0x1F;
  } else {
   dataEntry |= tempb;
  }
  break;
 case 6:
  temp = nibble[0] * 100 + nibble[1] * 10 + nibble[2];
  if (temp > 255) {
   dataEntry = 255;
  } else {
   dataEntry = temp;
  }
  break;
 case 7:
  dataEntry = nibble[0];
  if (dataEntry > 3){
   dataEntry = 0xFF;
  }
  break;
 case 8:
  dataEntry = nibble[0] & 0x03;
  break;
 case 9:
  dataEntry = nibble[0];
  break;
 case 10:
  dataEntry = 0;
  for (uint8_t i = 0; i<8; i++){
   dataEntry = dataEntry << 1;
   dataEntry = dataEntry + nibble[i];
  }
  break;
 case 11:
  dataEntry32 = 0;
  uint8_t i = 8;
  uint8_t * pWordByte = (uint8_t *) & (dataEntry32);
  while (i-- != 0){

   uint8_t tempByte = nibble[i--];
   tempByte += nibble[i] << 4;
   *pWordByte++ = tempByte;
  }
  break;
 case 12:
  dataEntry = (nibble[0]-1) | ((nibble[1]-1) << 3);
  break;
 case 13:
  dataEntry = (nibble[0] * 10 + nibble[1]) - 1;
  break;
 }
}

void menuTextOutVar(char* pChar, char finalChar){

 for (uint8_t i = 0; i < 10; i++){
  uint8_t outChar = *pChar;
  if (outChar == '\0'){
   outChar = finalChar;
   finalChar = ' ';
  } else {
   pChar++;
  }
  lcd_putc(outChar);
 }
}


void menuTextOut(const __flash char* pChar, char finalChar){

 for (uint8_t i = 0; i < 10; i++){
  uint8_t outChar = *pChar;
  if (outChar == '\0'){
   outChar = finalChar;
   finalChar = ' ';
  } else {
   pChar++;
  }
  lcd_putc(outChar);
 }
}

void menuParentMenuToLCD(){
 lcd_goto(0x40);
 if (menuStackIndex == 0) {

  menuTextOut(pMenuTopTitle, ':') ;
 } else {

  const __flash Menu_t* pTopMenu = menuStack[menuStackIndex-1];
  menuTextOut(pTopMenu->text, ':' );
 }
}

void menuCurrMenuToLCD(){

 lcd_goto((0x40 + 10)-1);
 uint8_t bound = currentMenu->menuType & 0xC0;

 if (bound == 0x80) {
  lcd_putc(' ');
  keylabel_clr(2);
 } else {
  lcd_putc(0x7F);
  softkeyLeft();
 }
 char rightDelimiter;

 if (bound == 0xC0) {
  rightDelimiter = ' ';
  keylabel_clr(3);
 } else {
  rightDelimiter = 0x7E;
  softkeyRight();
 }
 softkeyUp();
 softkeyDown();
 menuTextOut(currentMenu->text, rightDelimiter);
 keylabel_toLCD();
 menuCursorSetMenu();
}

void menuDisplayValue(){

 if ((currentMenu->menuType & 0x3F) > 1){
  dataToNibbles();
  nibbleToLCDstring();
  LCDStringOut();
 }
}

void menuCursorSetDataNibble(){

  lcd_goto((0+20 + 10) + pNibbleInfo->nibblePos[nibbleIndex]);
  if (nibbleIndex < pNibbleInfo->nibbleCount - 1) {
   softkeyRight();
  } else {
   keylabel_clr(3);
  }
  if (nibbleIndex > 0) {
   softkeyLeft();
  } else {
   keylabel_clr(2);
  }
  softkeyPlus();
  softkeyMinus();
  keylabel_toLCD();

}

static inline void menuCursorSetData(){

 lcd_goto((0+20 + 10));

}

void menuCursorSetExtra(){

 lcd_goto(0+20);
}

void menuCursorSetMenu(){

 lcd_goto((0x40 + 10));
}

static inline void menuCursorSetParent(){
 lcd_goto(0x40);
}

void menuClearExtraDisp(){
 menuCursorSetExtra();
 lcd_blank(10);
}

void menu_ClearDataDisp(){
 menuCursorSetData();
 lcd_blank(10);
}

void menuClearMenuDisp(){
 menuCursorSetParent();
 lcd_blank(10);
 menuCursorSetMenu();
 lcd_blank(10);
}

void menu_ClearAllDisp(){
 menuClearMenuDisp();
 menu_ClearDataDisp();
 menuClearExtraDisp();
}

void menuItemChanged(){


 swTimer[7].counter = 0xFF;
 if (((currentMenu->menuType & 0x3F) > 1) && (currentMenu->pVar != 
# 1903 ".././menu.c" 3 4
                                                                                               ((void *)0)
# 1903 ".././menu.c"
                                                                                                   )) {

  pNibbleInfo = &(nibbleInfo[(currentMenu->menuType & 0x3F) - 1]);
  nibbleCount = pNibbleInfo->nibbleCount;
  dataType = (currentMenu->menuType & 0x3F);
  uint8_t* pData = currentMenu->pVar + (((currentMenu->menuFlags & 0x80) != 0) ? DataAdressOffset : 0);
  if ((currentMenu->menuType & 0x3F) == 11) {
   dataEntry32 = * (uint32_t *) pData;
  } else {
   dataEntry = *pData;
  }
  menuDisplayValue();
 } else {
  menu_ClearDataDisp();
  pNibbleInfo = &(nibbleInfo[0]);
 }
 menuCursorSetMenu();
}

void menuResetVars(){

 menuMidiChan = 0;
 menuSection = 0;
 DataAdressOffset = 0;
}

uint8_t menu_ProcessMessage(uint8_t message){



 uint8_t menuFinished;
 menuFinished = 0x00;
 lcd_cursosblink();
 if (((currentMenu->menuType & 0x3F) == 1) || (nibbleIndex == 0xFF)){

  if ((currentMenu->menuFlags & 0x40) != 0) {
   menuClearExtraDisp();
   menuCursorSetMenu();
  }
  if (((currentMenu->menuFlags & 0x20) != 0) && (currentMenu->pFunc != 
# 1942 ".././menu.c" 3 4
                                                                                           ((void *)0)
# 1942 ".././menu.c"
                                                                                               ) && (nibbleIndex != 0xFF)) {


   if (currentMenu->pFunc (message) == 0xFF) {

    nibbleIndex = 0;
   } else {

    menuClearExtraDisp();
    menu_ClearDataDisp();
    menuCursorSetMenu();
    nibbleIndex = 0xFF;
    menuCurrMenuToLCD();
   }
  } else {

   switch (message){
   case 1:

    if ((currentMenu->menuType & 0xC0) != 0xC0){

     currentMenu++;
     menuItemChanged();
     menuCurrMenuToLCD();
    }
    break;
   case 4:

    if ((currentMenu->menuType & 0xC0) != 0x80){

     currentMenu--;
     menuItemChanged();
     menuCurrMenuToLCD();
    }
    break;
   case 2:
   case 6:

    if ((currentMenu->menuFlags & 0x10) != 0) {

     menuVMenuSoftKey = 
# 1982 ".././menu.c" 3 4
                       ((void *)0)
# 1982 ".././menu.c"
                           ;
    }
    if (menuStackIndex > 0){

     currentMenu = menuStack[--menuStackIndex];
     if (currentMenu->pOnExitFunc != 
# 1987 ".././menu.c" 3 4
                                    ((void *)0)
# 1987 ".././menu.c"
                                        ){

      currentMenu->pOnExitFunc (0);
     }
     menuClearExtraDisp();
     menuParentMenuToLCD();
     menuCurrMenuToLCD();

     menuItemChanged();
    } else {
     menuFinished = 0xFF;
     keylabel_clr(0);
     keylabel_clr(1);
     keylabel_clr(2);
     keylabel_clr(3);
     keylabel_toLCD();
     lcd_cursoroff();
    }
    break;
   case 3:
   case 5:

    if ((currentMenu->menuType & 0x3F) > 1) {

     if (currentMenu->pFunc != 
# 2011 ".././menu.c" 3 4
                              ((void *)0)
# 2011 ".././menu.c"
                                  ){
      currentMenu->pFunc(message);
      menuItemChanged();
     }
     if (((currentMenu->menuFlags & 0x08) == 0) && (currentMenu->pVar) != 
# 2015 ".././menu.c" 3 4
                                                                                       ((void *)0)
# 2015 ".././menu.c"
                                                                                           ){

      nibbleIndex = 0;
      menuCursorSetDataNibble();
     }
    } else {

     nibbleIndex = 0xFF;
     if ((currentMenu->menuFlags & 0x10) != 0) {

      menuVMenuSoftKey = currentMenu;
      if (menuStackIndex > 0){

       currentMenu = menuStack[--menuStackIndex];
       if (currentMenu->pOnExitFunc != 
# 2029 ".././menu.c" 3 4
                                      ((void *)0)
# 2029 ".././menu.c"
                                          ){

        currentMenu->pOnExitFunc (0);
       }
       menuClearExtraDisp();
       menuParentMenuToLCD();
       menuCurrMenuToLCD();

       menuItemChanged();
      }
     } else {

      if (currentMenu->pFunc != 
# 2041 ".././menu.c" 3 4
                               ((void *)0)
# 2041 ".././menu.c"
                                   ) {

       if ((currentMenu->menuFlags & 0x20) != 0) {


        if (currentMenu->pFunc (0xFF) == 0xFF) {
         nibbleIndex = 0;
        } else {

         menuClearExtraDisp();
         menu_ClearDataDisp();
         menuCursorSetMenu();
         nibbleIndex = 0xFF;
        }

       } else {

        currentMenu->pFunc (5);
        menuCursorSetMenu();
       }
      }
      if (currentMenu->pMenu != 
# 2062 ".././menu.c" 3 4
                               ((void *)0)
# 2062 ".././menu.c"
                                   ){

       if (menuStackIndex < 16) {
        menuStack[menuStackIndex++] = currentMenu;
        if (((currentMenu->menuFlags & 0x08) != 0) && (menuVMenuSoftKey != 
# 2066 ".././menu.c" 3 4
                                                                                                 ((void *)0)
# 2066 ".././menu.c"
                                                                                                     )) {

         currentMenu = menuVMenuSoftKey;
        } else {

         currentMenu = currentMenu->pMenu;
        }
        menuClearExtraDisp();
        menuParentMenuToLCD();
        menuCurrMenuToLCD();

        menuItemChanged();
       }
      }
     }
    }
    break;
   }
  }
 } else {

  switch (message){
  case 1:

   if (nibbleIndex < pNibbleInfo->nibbleCount - 1){
    nibbleIndex++;
    menuCursorSetDataNibble();
   }
   break;
  case 4:

   if (nibbleIndex > 0){
    nibbleIndex--;
    menuCursorSetDataNibble();
   }
   break;
  case 2:

   nibbleChange(nibbleIndex,1);
   nibbleToData();
   menuDisplayValue();
   if (dataType == 10) {

    if (nibbleIndex < pNibbleInfo->nibbleCount - 1){
     nibbleIndex++;
    }
   }
   menuCursorSetDataNibble();
   break;
  case 3:

   nibbleChange(nibbleIndex,-1);
   nibbleToData();
   menuDisplayValue();
   if (dataType == 10) {
    if (nibbleIndex < pNibbleInfo->nibbleCount - 1){
     nibbleIndex++;
    }
   }
   menuCursorSetDataNibble();
   break;
  case 5:

   nibbleToData();
   if (currentMenu->pVar != 
# 2130 ".././menu.c" 3 4
                           ((void *)0)
# 2130 ".././menu.c"
                               ){
    uint8_t* pData = (currentMenu->pVar) + (((currentMenu->menuFlags & 0x80) != 0) ? DataAdressOffset : 0);
    if ((currentMenu->menuType & 0x3F) == 11) {
     * (uint32_t *) pData = dataEntry32;
    } else {
     *pData = dataEntry;
    }
   }
  case 6:
   if (currentMenu->pOnExitFunc != 
# 2139 ".././menu.c" 3 4
                                  ((void *)0)
# 2139 ".././menu.c"
                                      ){
    currentMenu->pOnExitFunc (message);
   }
   nibbleIndex = 0xFF;
   menuCurrMenuToLCD();
   menuItemChanged();
   break;
  }
 }
 return menuFinished;
}


uint8_t SoftKeyFunctionOK(MenuFunc_t softKeyFunc){

 uint8_t functionCount = sizeof(menu_selFunc) / sizeof(menu_selFunc[0]);
 for (uint8_t i = 0; i < functionCount; i++){
  if (menu_selFunc[i].pFunc == softKeyFunc){
   return 0xFF;
  }
 }
 return 0x00;
}


void init_SoftKeys(){
 if (eeprom_ReadSoftkeys() == 0xFF){

  for (uint8_t i = 0; i<4; i++){
   soft_KeyMenuIndex[i] = 0;
   soft_KeyMenu[i].pSelMenu = 
# 2169 ".././menu.c" 3 4
                             ((void *)0)
# 2169 ".././menu.c"
                                 ;
  }

  log_putError(1,7,0);
 }
 for (uint8_t i = 0; i<4; i++){
  const uint8_t SoftKeyMenuListLen = sizeof(menu_selFunc) / sizeof(menu_selFunc[0]);
  if (soft_KeyMenuIndex[i] < SoftKeyMenuListLen){

   soft_KeyMenu[i].pSelMenu = &menu_selFunc[soft_KeyMenuIndex[i]];
  } else {
   soft_KeyMenu[i].pSelMenu = 
# 2180 ".././menu.c" 3 4
                             ((void *)0)
# 2180 ".././menu.c"
                                 ;
   log_putError(1,7,i+1 | 0x10);
  }
 }
}

void softKey_Set(const __flash Menu_t* pSelMenuSoftKey, uint8_t nrSoftKey){
 if (nrSoftKey < 4) {
  if ((pSelMenuSoftKey != 
# 2188 ".././menu.c" 3 4
                         ((void *)0)
# 2188 ".././menu.c"
                             ) && ((pSelMenuSoftKey->menuType & 0x3F) == 1) && ((pSelMenuSoftKey->menuFlags & 0x10) != 0)){
   soft_KeyMenu[nrSoftKey].pSelMenu = pSelMenuSoftKey;
   soft_KeyMenuIndex[nrSoftKey] = (pSelMenuSoftKey - &menu_selFunc[0]) / sizeof(menu_selFunc[0]);
  } else {
   soft_KeyMenu[nrSoftKey].pSelMenu = 
# 2192 ".././menu.c" 3 4
                                     ((void *)0)
# 2192 ".././menu.c"
                                         ;
   soft_KeyMenuIndex[nrSoftKey] = 0;
  }
 }
}

void softKeys_toLCD(){
 for (uint8_t i = 0; i<4; i++){
  if ((soft_KeyMenu[i].pSelMenu == 
# 2200 ".././menu.c" 3 4
                                  ((void *)0)
# 2200 ".././menu.c"
                                      ) || (soft_KeyMenu[i].pSelMenu->pString == 
# 2200 ".././menu.c" 3 4
                                                                                 ((void *)0)
# 2200 ".././menu.c"
                                                                                     )){
   keylabel_clr(i);
  } else {
   keylabel_set(i,(soft_KeyMenu[i].pSelMenu->pString));
   if (soft_KeyMenu[i].pSelMenu->pFunc != 
# 2204 ".././menu.c" 3 4
                                         ((void *)0)
# 2204 ".././menu.c"
                                             ){

    keylabel_statcheck(i,soft_KeyMenu[i].pSelMenu->pFunc(0)== 0x81 ? 0xFF : 0x00);
   }
  }
 }
 keylabel_toLCD();
}

uint8_t softKey_MessageKey_ToSoftKeyNr(uint8_t messageKey){
 switch (messageKey){
  case 2:
   return 0;
  case 3:
   return 1;
  case 4:
   return 2;
  case 1:
   return 3;
 }
 return 0xFF;
}

uint8_t softKey_Execute(uint8_t nrSoftKey, uint8_t myMessage){

 if (nrSoftKey < 4) {

  const __flash Menu_t* pSoftKeySelMenu = soft_KeyMenu[nrSoftKey].pSelMenu;
  if (pSoftKeySelMenu != 
# 2232 ".././menu.c" 3 4
                        ((void *)0)
# 2232 ".././menu.c"
                            ){

   if (((pSoftKeySelMenu->menuType & 0x3F) == 1) && ((pSoftKeySelMenu->menuFlags & 0x10) != 0)){
    if (pSoftKeySelMenu->pFunc != 
# 2235 ".././menu.c" 3 4
                                 ((void *)0)
# 2235 ".././menu.c"
                                     ) {

     uint8_t softKeyFuncResult;
     softKeyFuncResult = pSoftKeySelMenu->pFunc(myMessage);

     if (softKeyFuncResult == 0x82){
      keylabel_statcheck(nrSoftKey, 0x00);
     } else if (softKeyFuncResult == 0x81){
      keylabel_statcheck(nrSoftKey, 0xFF);
     }
     keylabel_toLCD();
    }

    const __flash Menu_t* pSoftKeyExeMenu = pSoftKeySelMenu->pMenu;
    if (pSoftKeyExeMenu != 
# 2249 ".././menu.c" 3 4
                          ((void *)0)
# 2249 ".././menu.c"
                              ) {

     menu_Init(pSoftKeyExeMenu, pSoftKeySelMenu->text);
     menu_InitLCD();
     return 0x00;
    }
   }
  }
 }
 return 0xFF;
}



void menu_showPowerState(){
 uint8_t saveCursor = lcd_cursorPos;
 lcd_goto(((0 +10-3)+5));
 lcd_putc((pipe_PowerStatus & 0x10 ? ' ' : 0x09));
 lcd_goto(saveCursor);

}
